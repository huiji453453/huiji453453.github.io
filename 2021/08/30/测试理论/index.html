<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>测试理论 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.软件研发流程1. 软件的开发模型软件测试工作与软件开发模型息息相关，在不同的软件开发模型中，测试的任务和作用也不相同，因此测试人员要充分了解软件开发模型，以便找准自己在其中的定位与任务。 软件开发模型规定了软件开发应遵循的步骤，是软件开发的导航图，它能够清晰、直观地表达软件开发的全过程，以及每个阶段要进行的活动和要完成的任务。 开发人员在选择开发模型时，要根据软件的特点、开发人员的参与方式选择">
<meta property="og:type" content="article">
<meta property="og:title" content="测试理论">
<meta property="og:url" content="http://example.com/2021/08/30/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.软件研发流程1. 软件的开发模型软件测试工作与软件开发模型息息相关，在不同的软件开发模型中，测试的任务和作用也不相同，因此测试人员要充分了解软件开发模型，以便找准自己在其中的定位与任务。 软件开发模型规定了软件开发应遵循的步骤，是软件开发的导航图，它能够清晰、直观地表达软件开发的全过程，以及每个阶段要进行的活动和要完成的任务。 开发人员在选择开发模型时，要根据软件的特点、开发人员的参与方式选择">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-08-30T08:58:08.000Z">
<meta property="article:modified_time" content="2021-08-30T09:49:49.313Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-测试理论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/30/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2021-08-30T08:58:08.000Z" itemprop="datePublished">2021-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      测试理论
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-软件研发流程"><a href="#1-软件研发流程" class="headerlink" title="1.软件研发流程"></a>1.软件研发流程</h1><h2 id="1-软件的开发模型"><a href="#1-软件的开发模型" class="headerlink" title="1. 软件的开发模型"></a>1. 软件的开发模型</h2><p>软件测试工作与软件开发模型息息相关，在不同的软件开发模型中，测试的任务和作用也不相同，因此测试人员要充分了解软件开发模型，以便找准自己在其中的定位与任务。</p>
<p>软件开发模型规定了软件开发应遵循的步骤，是软件开发的导航图，它能够清晰、直观地表达软件开发的全过程，以及每个阶段要进行的活动和要完成的任务。</p>
<p>开发人员在选择开发模型时，要根据软件的特点、开发人员的参与方式选择稳定可靠的开发模型自有软件开发以来，软件开发模型也从最初的“边做边改”发展出了多个模型，下面以软件开发模型发展历史为顺序，介绍几个典型的开发模型。</p>
<ol>
<li>瀑布模型</li>
</ol>
<p>在20世纪70年代，由温斯顿·罗伊斯（Winston Royce）提出，瀑布模型一直是惟一被广泛采用的软件过程模型，现在它仍然是软件工程中应用得非常广泛的过程模型。瀑布模型是一种线形的、顺序的软件开发模型，主要分为6个阶段:可行性计划研究→需求分析→软件设计→编码→测试→运行维护。 </p>
<p>图1-2所示瀑布模型</p>
<p>在瀑布模型中，软件开发的各项活动严格按照这条线进行，只有当一个阶段任务完成之后才能开始下一个阶段。软件开发的每一个阶段都要有结果产出，结果经过审核验证之后作为下一个阶段的输入，下个阶段才可以顺利进行。如果结果审核验证不通过，则需要返回修改。</p>
<p>瀑布模型为整个项目划分了清晰的检查点，当一个阶段完成之后，只需要把全部精力放置在后面的开发上即可，它有利于大型软件开发人员的组织管理及工具的使用与研究，可以提高开发的效率。</p>
<p>但是瀑布模型是严格按照线性方式进行的，无法适应用户需求变更，用户只能等到最后才能看到开发成果，增加了开发风险。如果开发人员与客户对需求理解有偏差，到最后开发完成后，最终成果与客户需求可能会差之千里。使用瀑布模型开发软件时，如果早期犯的错误在项目完成后才发现，此时再修改原来的错误需要付出巨大的代价。瀑布模型要求每一个阶段必须有结果产出，这就势必增加了文档的数量，使软件开发的工作量变大。</p>
<ol start="2">
<li>V模型</li>
</ol>
<p>V 模型最早是由Paul Rook 在20 世纪80 年代后期提出的，V 模型在英国国家计算中心文献中发布，目的是改进软件开发的效率和效果。它是软件测试最具代表性的测试模型之一。</p>
<p>在传统的开发模型中，如瀑布模型，通常把软件测试过程作为在需求分析、概要设计、详细设计和编码全部完成之后的一个阶段，尽管有时软件测试工作会占整个项目周期一半的时间，但是仍然被认为软件测试只是一个收尾工作，而不是主要的工程。故对以前的测试模型进行了一定程度的改进，V 模型其实是软件开发瀑布模型的变种，反映了软件测试活动与软件开发过程(从分析到设计)的关系。</p>
<p>V 模型从左到右，描述了基本的开发过程和测试行为，明确地标明了测试工程中存在的不同级别以及测试阶段和开发过程各阶段的对应关系。图中箭头代表了时间方向，左边下降的是开发过程各阶段，与此相对应的是右边上升的部分，即测试过程各阶段。</p>
<p>V 模型指出，单元和集成测试是验证程序设计，单元测试主要由白盒测试工程对代码进行测试，但目前国内真正做白盒测试的企业不多。这主要有两大原因：第一，白盒测试投入的成本很高，并且产出不明显，很多企业不希望投入更多的资源去做这项工作;第二，白盒测试对测试工程师的要求较高，在目前系统测试还没有完全成熟的情况下很难真正地开展白盒测试。而集成测试是介于白盒测试与系统测试之间的一种测试，也叫灰盒测试，由于它与白盒测试和系统测试之间没有明显的界限，所以在实际的测试过程中，即使开展集成测试也是由系统测试工程师来完成。</p>
<p>系统测试主要验证系统设计，检测系统功能、性能的质量特性是否达到系统设计的指标，由测试人员和用户进行软件的确认测试和验收测试，以及对需求说明书进行测试，以确定软件的实现是否满足用户需求或合同要求。</p>
<p>V 模型存在一定的局限性，它把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段。如果不做白盒测试，那么其实都是在系统完成集成后才开始系统测试的，这样需求分析阶段隐藏的问题一直到后期的验收测试才被发现，因此修改缺陷的成本就高了很多。</p>
<ol start="3">
<li>快速原型模型</li>
</ol>
<p>快速原型模型与瀑布模型正好相反，它在最初确定用户需求时快速构造岀一个可以运行的软件原型，这个软件原型向用户展示待开发软件的全部或部分功能和性能，客户对该原型进行审核评价，然后给出更具体的需求意见，这样逐步丰富细化需求，最后开发人员与客户达成最终共识，确定客户的真正需求。确定客户的真正需求之后，开始真正的软件开发。</p>
<p>快速原型模型类似于建造房子，确定客户对房子的需求之后快速地搭建一个房子模型，由客户对房子模型进行评价，房子的样式、功能、布局等是否满足需求，哪里需要改进等，最后确定了客户对房子的要求，就开始真正地建造房子。</p>
<p>与瀑布模型相比，快速原型模型克服了需求不明确带来的风险，适用于不能预先确定需求的软件项目。但快速原型模型关键在于快速构建软件原型，准确地设计出软件原型存在定的难度。此外，这种开发模型也不利于开发人员对产品进行扩展。</p>
<ol start="4">
<li>迭代模型</li>
</ol>
<p>迭代模型又称为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，然后逐个组件地开发测试，每完成一个组件就展现给客户，让客户确认这一部件功能和性能是否达到客户需求，最终确定无误，将组件集成到软件体系结构中。</p>
<p>整个开发工作被组织为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析→软件设计→编码→测试的过程。</p>
<p>在迭代模型中，第一个迭代(即第一个组件)往往是软件基本需求的核心部分，第一个组件完成之后，经过客户审核评价形成下一个组件的开发计划，包括对核心产品的修改和新功能的发布，这样重复迭代步骤直到实现最终完善的产品。</p>
<p>迭代模型可以很好地适应客户需求变更，它逐个组件地交付产品，客户可以经常看到产品，如果某个组件没有满足客户需求，则只需要更改这一个组件，降低了软件开发的成本与风险。但是选代模型需要将开发完成的组件集成到软件体系结构中，这样会有集成失败的风险，因此要求软件必须有开放式的体系结构。此外，迭代模型逐个组件地开发修改，很容易退化为“边做边改”的开发形式，从而失去对软件开发过程的整体控制。</p>
<ol start="5">
<li>螺旋模型</li>
</ol>
<p>螺旋模型由巴利·玻姆(Barry Boehm)于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。</p>
<p>螺旋模型将整个项目开发过程划分为几个不同的阶段，每个阶段按部就班地执行，这种划分方式采用了瀑布模型。每个阶段在开始之前都要进行风险评估，如果能消除重大风险则可以开始该阶段任务。在每个阶段，首先构建软件原型，根据快速原型模型完成这个迭代过程，产出最终完善的产品，然后进入下一个阶段，同样下一个阶段开始之前也要进行风险评估，这样循环往复直到完成所有阶段的任务。螺旋模型的若干个阶段是沿着螺线方式进行的。</p>
<p>制订计划、风险分析、实施工程、客户评估，各象限含义如下。</p>
<p>(1)制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。</p>
<p>(2)风险分析:评价所制订的实施方案，识别风险并消除风险。</p>
<p>(3)实施工程:开发产品并进行验证</p>
<p>(4)客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。</p>
<p>在螺旋模型中，每一个选代都需要经过这4个步骤，直到最后得到完善的产品，可以进行提交。</p>
<p>螺旋模型强调了风险分析，这意味着对可选方案和限制条件都进行了评估，更有助于将软件质量作为特殊目标融入产品开发之中。它以小分段构建大型软件，使成本计算变得简单容易，而且客户始终参与每个阶段的开发，保证了项目不偏离正确方向，也保证了项目的可控制性。</p>
<h2 id="2-软件开发生命周期"><a href="#2-软件开发生命周期" class="headerlink" title="2. 软件开发生命周期"></a>2. 软件开发生命周期</h2><p>软件和其他产品一样，都有一个从“出生”到“消亡”的过程，这个过程称为软件的生命周期。在软件的生命周期中，软件测试是非常重要的一个环节。</p>
<p>软件生命周期分为多个阶段，每个阶段有明确的任务，这样就使得结构复杂、管理复杂的软件开发变得容易控制和管理。通常，可将软件生命周期划分为6个阶段，每个阶段的目标任务及含义分别介绍如下。</p>
<p>第1阶段:问题定义，该阶段由软件开发方与需求方共同讨论，主要确定软件的开发目标及其可行性。</p>
<p>第2阶段:需求分析，该阶段对软件需求进行更深入的分析，划分出软件需要实现的功能模块，并制作成文档。需求分析在软件的整个生命周期中起着非常重要的作用，它直接关系到后期软件开发的成功率。在后期开发中，需求可能会发生变化，因此，在进行需求分析时，应考虑到需求的变化，以保证整个项目的顺利进行。</p>
<p>第3阶段:软件设计，该阶段在需求分析结果的基础上，对整个软件系统进行设计，如系统框架设计、数据库设计等。</p>
<p>第4阶段:软件开发，该阶段在软件设计的基础上，选择一种编程语言进行开发。在开发过程中，必须要制订统一的、符合标准的程序编写规范，以保证程序的可读性、易维护性以及可移植性。</p>
<p>第5阶段:软件测试，该阶段是软件开发完成后对软件进行测试，以查找软件设计与软件开发过程中存在的问题并加以修正。软件测试过程包括单元测试、集成测试、系统测试、验收测试等4个阶段;测试的方法以黑盒测试、白盒测试或者两者结合的形式进行。在测试过程中，为减少测试的随意性，需要制订详细的测试计划并严格遵守;测试完成之后，要对测试结果进行分析并对测试结果以文档的形式汇总。</p>
<p>第6阶段:软件维护，软件完成测试并投入使用之后，面对庞大的用户群体，软件可能无法满足用户使用需求，此时就需要对软件进行维护升级以延续软件的使用寿命。软件的维护包括纠错性维护和改进性维护两个方面。软件维护是软件生命周期中持续时间最长的阶段。</p>
<h2 id="3-项目团队里面的成员及其职责"><a href="#3-项目团队里面的成员及其职责" class="headerlink" title="3. 项目团队里面的成员及其职责"></a>3. 项目团队里面的成员及其职责</h2><p>项目经理：驱动整个项目的运转，负责制定计划，安排人力，管理进度，协调团队，进行重大决策。</p>
<p>架构师 / 系统工程师：技术专家，经验丰富，负责整个系统的体系架构的设计以及关键模块的设计。</p>
<p>程序员 / 开发人员：设计、编写软件，并修复软件中的缺陷。</p>
<p>测试工程师：负责找出软件产品存在的问题并报告。</p>
<p>实施/运维工程师：负责软件系统安装部署、升级维护。</p>
<p>资料工程师：负责编写软件产品附带的文件和联机帮助文档</p>
<p>配置管理员：负责管理程序员写的代码和资料工程师写的文档资料，并组合成一个软件包。</p>
<p>QA：质量监管人员</p>
<h1 id="2-软件测试的基础理论"><a href="#2-软件测试的基础理论" class="headerlink" title="2.软件测试的基础理论"></a>2.软件测试的基础理论</h1><h2 id="1-软件测试的定义"><a href="#1-软件测试的定义" class="headerlink" title="1.软件测试的定义"></a>1.软件测试的定义</h2><p>软件测试是使用人工或者自动手段运行或测定某个系统的过程，检验系统是否满足规定的需求，并找出预期结果与实际结果的差异。</p>
<h2 id="2-测试的对象"><a href="#2-测试的对象" class="headerlink" title="2.测试的对象"></a>2.测试的对象</h2><p>根据软件的定义，软件包括程序、文档，所以软件测试并不仅仅是程序测试。软件测试贯穿于整个软件生命周期中。</p>
<h2 id="3-软件测试的目的"><a href="#3-软件测试的目的" class="headerlink" title="3.软件测试的目的"></a>3.软件测试的目的</h2><p>软件测试的目的大家都能随口说出，如查找程序中的错误、保证软件质量、检验软件是否符合客户需求等。这些都对，但它们只是笼统地对软件测试目的进行了概括，比较片面结合软件开发、软件测试与客户需求可以将软件测试的目的归结为以下几点。</p>
<ol>
<li><p>预防缺陷，减少产品的风险：对于软件开发来说，软件测试通过找到的问题缺陷帮助开发人员找到开发过程中存在的问题，包括软件开发的模式、工具、技术等方面存在的问题与不足，预防下次缺陷的产生。</p>
</li>
<li><p>发现被测对象与用户需求之间的差异（俗称找BUG）</p>
</li>
<li><p>通过测试活动发现并解决缺陷，增加人们对被测对象的质量信心；</p>
</li>
<li><p>通过测试活动，发现被测对象的质量信息，为决策者提供数据依据；</p>
</li>
</ol>
<h2 id="4-软件测试应遵循的原则"><a href="#4-软件测试应遵循的原则" class="headerlink" title="4.软件测试应遵循的原则"></a>4.软件测试应遵循的原则</h2><ol>
<li>测试应该基于客户的需求</li>
<li>测试要尽早进行</li>
<li>穷尽测试是不可能的</li>
<li>测试缺陷要符合“二八”定理</li>
<li>杀虫剂的悖论</li>
<li>没有缺陷的软件是不存在的</li>
</ol>
<h1 id="3-软件测试的分类"><a href="#3-软件测试的分类" class="headerlink" title="3.软件测试的分类"></a>3.软件测试的分类</h1><h2 id="1-按照测试阶段划分"><a href="#1-按照测试阶段划分" class="headerlink" title="1.按照测试阶段划分"></a>1.按照测试阶段划分</h2><p>①　单元测试</p>
<p>单元测试是软件开发的第一步测试，目的是为了验证软件单元是否符合软件需求与设计。单元测试大多是开发人员进行的自测。</p>
<p>②　冒烟测试</p>
<p>冒烟测试最初是从电路板测试得来的，当电路板做好以后，首先会加电测试，如果电路板没有冒烟再进行其他测试，否则就必须重新设计后再次测试。</p>
<p>后来这种测试理念被引入到软件测试中。在软件测试中，冒烟测试是指软件构建版本建立后，对系统的基本功能进行简单的测试，这种测试重点验证的是程序的主要功能，而不会对具体功能进行深入测试。</p>
<p>如果测试未通过，需要返回给开发人员进行修正;如果测试通过则再进行其他测试。因此，冒烟测试是对新构建版本软件进行的最基本测试。</p>
<p>③　集成测试</p>
<p>集成测试是冒烟测试之后进行的测试，它是将已经测试过的软件单元组合在一起测试它们之间的接口，用于验证软件是否满足设计需求。</p>
<p>④　系统测试</p>
<p>系统测试是将经过测试的软件在实际环境中运行，并与其他系统的成分(如数据库、硬件和操作人员等)组合在一起进行的测试。</p>
<p>⑤　验收测试</p>
<p>验收测试主要是对软件产品说明进行验证，逐行逐字地按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。</p>
<h2 id="2-按照测试技术分类"><a href="#2-按照测试技术分类" class="headerlink" title="2.按照测试技术分类"></a>2.按照测试技术分类</h2><p>①　黑盒测试</p>
<p>不需要关注被测对象的内部结构，仅从用户需求的角度去考虑，是否满足显性或者隐性的需求。</p>
<p>②　白盒测试</p>
<p>白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程。</p>
<h2 id="3-按照软件质量分类"><a href="#3-按照软件质量分类" class="headerlink" title="3.按照软件质量分类"></a>3.按照软件质量分类</h2><p>①　功能测试</p>
<p>功能测试就是测试软件的功能是否满足客户的需求，包括准确性、易用性、适合性、互操作性等。</p>
<p>②　性能测试</p>
<p>性能测试就是测试软件的性能是否满足客户的需求，性能测试包括负载测试、压力测试、兼容性测试、可移植性测试和健壮性测试。</p>
<h2 id="4-按照自动化程度分类"><a href="#4-按照自动化程度分类" class="headerlink" title="4.按照自动化程度分类"></a>4.按照自动化程度分类</h2><p>按照自动化程度可以将软件测试分为手工测试与自动化测试。</p>
<p>①　手工测试</p>
<p>手工测试是测试人员一条一条地执行代码完成测试工作。手工测试比较耗时费力，而且测试人员如果是在疲惫状态下，则很难保证测试的效果。</p>
<p>②　自动化测试</p>
<p>自动化测试是借助脚本、自动化测试工具等完成相应的测试工作，它也需要人工的参与，但是它可以将要执行的测试代码或流程写成脚本，执行脚本完成整个测试工作。</p>
<h2 id="5-按照测试类型分类"><a href="#5-按照测试类型分类" class="headerlink" title="5.按照测试类型分类"></a>5.按照测试类型分类</h2><p>软件测试类型有多种，包括界面类测试、功能测试、性能测试、安全性测试、文档测试等，其中功能测试与性能测试前面已经介绍，下面主要介绍其他几种测试。</p>
<p>①　界面类测试</p>
<p>界面类测试是验证软件界面是否符合客户需求，包括界面布局是否美观、按钮是否齐全等。</p>
<p>②　安全性测试</p>
<p>安全性测试是测试软件在没有授权的内部或外部用户的攻击或恶意破坏时如何进行处理，是否能保证软件与数据的安全。</p>
<p>③　文档测试</p>
<p>文档测试以需求分析、软件设计、用户手册、安装手册为主，主要验证文档说明与实际软件之间是否存在差异。</p>
<h2 id="6-其他分类"><a href="#6-其他分类" class="headerlink" title="6.其他分类"></a>6.其他分类</h2><p>还有一些软件测试无法具体归到哪一类，但在测试行业中也会经常进行这些测试，如α测试、β测试、回归测试等，具体介绍如下。</p>
<p>①　α测试</p>
<p>α测试是指对软件最初版本进行测试。软件最初版本一般不对外发布，在上线之前，由开发人员和测试人员或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题整个测试过程是可控的。</p>
<p>②　β测试</p>
<p>β测试是指对上线之后的软件版本进行测试，此时软件已上线发布，但发布的版本中可能会存在较轻微的Bug，由用户在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。</p>
<p>③　回归测试</p>
<p>当测试人员发现缺陷以后，会将缺陷提交给开发人员，开发人员对程序进行修改，修改之后，测试人员会对修改后的程序重新进行测试，确认原有的缺陷已经消除并且没有引入新的缺陷，这个重新测试的过程就叫作回归测试。回归测试是软件测试工作中非常重要的一部分，软件开发的各个阶段都会进行多次回归测试。</p>
<p>④　随机测试</p>
<p>随机测试是没有测试用例、检查列表、脚本或指令的测试，它主要是根据测试人员的经验对软件进行功能和性能抽查。随机测试是根据测试用例说明书执行测试用例的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</p>
<h1 id="4-软件测试流程"><a href="#4-软件测试流程" class="headerlink" title="4.软件测试流程"></a>4.软件测试流程</h1><ol>
<li>测试需求分析阶段：</li>
</ol>
<p>阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议;</p>
<ol start="2">
<li>测试计划阶段：</li>
</ol>
<p>根据自己的角色说明 如:测试经理主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围(来自需求文档)，进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。测试人员的话一般是领取分配的测试任务;</p>
<ol start="3">
<li>测试设计阶段：</li>
</ol>
<p>主要是编写测试用例，会参考需求文档(原型图)，概要设计，详细设计等文档，用例编写完成之后会进行评审;</p>
<ol start="4">
<li>测试执行阶段：</li>
</ol>
<p>搭建环境，执行冒烟测试(预测试)，然后进入正式测试，bug管理,根据公司情况进行日报,周报跟踪进度及风险控制;</p>
<ol start="5">
<li>测试评估阶段：</li>
</ol>
<p>出测试报告，确认是否可以上线。</p>
<h1 id="5-测试文档介绍"><a href="#5-测试文档介绍" class="headerlink" title="5.测试文档介绍"></a>5.测试文档介绍</h1><p>在软件研发过程当中，会产生很多的文档，下面罗列测试阶段所产生的文档，包含但不仅限于如下文档。</p>
<table>
<thead>
<tr>
<th>文档的名称</th>
<th>包括但不限于以下内容</th>
<th>文档编写目的</th>
</tr>
</thead>
<tbody><tr>
<td>测试计划</td>
<td>测试的范围、测试的准则、测试的手段、测试工具、停止的标准、硬/软件环境、测试规划、测试执行、工作量预估、资源安排、进度安排、风险管理等。</td>
<td>明确测试工作内容（范围）、测试工作的方法以及测试工作所需要的各种资源。</td>
</tr>
<tr>
<td>测试用例</td>
<td>用例编号、用例名称、测试背景、测试数据、操作步骤、预期结果、实际结果、优先级、重要级、编写人、执行人、备注等。</td>
<td>避免漏测、多测，能够对项目的需求做一个理解，可以作为测试人员工作量的一个考核。</td>
</tr>
<tr>
<td>缺陷报告</td>
<td>缺陷编号、缺陷描述、严重度、缺陷状态、发现人、发现时间、修复时间、所属版本、所属模块、修复的优先级、详细描述、下一步处理人等。</td>
<td>把软件存在的缺陷准确的描述出来，便于开发人员修正，反映了当前产品的质量状态，更是测试人员价值的体现。</td>
</tr>
<tr>
<td>测试报告</td>
<td>包括项目背景、需求分析、测试时间、测试环境、评审记录、测试范围、测试用例、功能实现清单、缺陷统计、测试统计(包含资源、执行、问题统计)、测试总结是否通过、测试的风险。</td>
<td>把测试的过程和结果写成文档，对发现的问题和缺陷进行分析，为纠正软件的存在的质量问题提供依据，同时为软件验收和交付打下基础。</td>
</tr>
<tr>
<td>测试日、周报</td>
<td>1.当前测试进度的关键性数据(用例执行进度、发现问题情况、待回归的问题)2.遇到哪些测试活动中不能解决的问题风险，需要什么样的帮助。3.下一阶段的工作计划是什么？</td>
<td>要求内容是每日/周测试活动的概述，和下一天/周测试活动的计划，要求反映出当前测试进度，成果及问题。</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/30/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/" data-id="cksygndmw0000boty9zoqhicf" data-title="测试理论" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/08/31/appium%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          appium环境搭建
        
      </div>
    </a>
  
  
    <a href="/2021/08/30/python%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">python学习相关</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/31/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/">黑盒测试方法</a>
          </li>
        
          <li>
            <a href="/2021/08/31/%E7%BC%BA%E9%99%B7%E7%9A%84%E5%A4%84%E7%90%86/">缺陷的处理</a>
          </li>
        
          <li>
            <a href="/2021/08/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/">软件测试流程</a>
          </li>
        
          <li>
            <a href="/2021/08/31/ftp%E5%B7%A5%E5%85%B7%E7%9A%84%E6%90%AD%E5%BB%BA/">ftp工具的搭建</a>
          </li>
        
          <li>
            <a href="/2021/08/31/appium%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">appium环境搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>