<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-adb命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/01/adb%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2021-09-01T08:11:53.000Z" itemprop="datePublished">2021-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/01/adb%E5%91%BD%E4%BB%A4/">adb命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、Android-调试桥"><a href="#一、Android-调试桥" class="headerlink" title="一、Android 调试桥"></a>一、Android 调试桥</h2><p>adb ( Android Debug Bridge)是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用。</p>
<h2 id="二、adb-的工作原理"><a href="#二、adb-的工作原理" class="headerlink" title="二、adb 的工作原理"></a>二、adb 的工作原理</h2><p>启动一个 adb 客户端时，此客户端首先检查是否有已运行的 adb 服务器进程。如果没有，它将启动服务器进程。当服务器启动时，它与本地 TCP 端口 5037 绑定，并侦听从 adb 客户端发送的命令—所有 adb 客户端均使用端口 5037 与 adb 服务器通信</p>
<h2 id="三、adb常用命令"><a href="#三、adb常用命令" class="headerlink" title="三、adb常用命令"></a>三、adb常用命令</h2><h5 id="查看adb版本"><a href="#查看adb版本" class="headerlink" title="查看adb版本"></a>查看adb版本</h5><p><code>adb  version</code></p>
<h5 id="连接夜神模拟器"><a href="#连接夜神模拟器" class="headerlink" title="连接夜神模拟器"></a>连接夜神模拟器</h5><p><code>adb connect 127.0.0.1:62001</code></p>
<p>连接自己的安卓手机查看下方的链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39969226/article/details/87897863">https://blog.csdn.net/qq_39969226/article/details/87897863</a></p>
<p>夜神模拟器的端口是规律的，第一个模拟器端口是62001，第二个模拟器端口是62025，第三个是62025+1，依此类推。</p>
<h5 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h5><p><code>adb devices</code></p>
<p>如果出现如下提示：</p>
<p><code>adb server version (31) doesn&#39;t match this client (36); killing...</code></p>
<p>· 原因： adb版本不对 ,Androd SDK的版本和模拟器的adb版本不一致</p>
<p>· <strong>解决方案：将Android SDK的 adb替换掉模拟器的adb和nox——adb即可。模拟器adb路径 ：{安装Path}Noxbin</strong></p>
<h5 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h5><p>android 设备底层是 linux 系统，所以连接上设备，也可以在adb命令行中操作对应的Linux指令。</p>
<p> shell 是 linux 系统的字符交互界面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#进入指定设备shell</span><br><span class="line"></span><br><span class="line">adb  -s 127.0.0.1:62001 shell</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#退出adb shell</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>进入adb shell后有两种状态显示：#代表有root权限，$代表没有root权限</p>
<p><code>root@android:/ #</code></p>
<p><code>shell@mx4:/ $</code></p>
<h6 id="root知识小科普"><a href="#root知识小科普" class="headerlink" title="root知识小科普"></a>root知识小科普</h6><p>“To err is human, but to really foul up everything, you need root password.”</p>
<p>“人非圣贤孰能无过，但是拥有root密码就真的万劫不复了。”</p>
<p>root用户是系统中唯一的超级管理员，它具有等同于操作系统的权限。一些需要root权限的应用，譬如广告阻挡，卸载系统预装App是需要root权限的。</p>
<h5 id="Adb相关命令参考"><a href="#Adb相关命令参考" class="headerlink" title="Adb相关命令参考"></a>Adb相关命令参考</h5><p>下面的命令在连接夜神模拟器之后进行操作</p>
<p>命令参考夜神模拟器官网</p>
<p><a target="_blank" rel="noopener" href="https://www.yeshen.com/faqs/H15tDZ6YW">https://www.yeshen.com/faqs/H15tDZ6YW</a></p>
<p>1、如何把电脑上的文件或文件夹传到模拟器里面？</p>
<p>adb push D:/sex.avi /mnt/avi/</p>
<p>2、如何把模拟器里面的文件或文件夹传到电脑上？</p>
<p>adb pull /mnt/avi/sex.avi D:/avi/</p>
<p>3、安装APK</p>
<p>adb install d:qq.apk</p>
<p>安装报错参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxs1314/p/6214154.html">https://www.cnblogs.com/lxs1314/p/6214154.html</a></p>
<p>4、卸载APK</p>
<p>adb uninstall 包名</p>
<p>比如卸载QQ：adb uninstall com.tencent.mobileqq</p>
<p>5、PM包命令</p>
<p>1）获取模拟器所有包名</p>
<p>adb shell pm list packages</p>
<p>2）获取模拟器所有包名并且包括APK路径</p>
<p>adb shell pm list packages -f</p>
<p>3）获取包名对应的APK路径</p>
<p>adb shell pm path packageName</p>
<p>4）清理应用数据</p>
<p>adb shell pm clear packageName</p>
<p>6、启动应用</p>
<p>adb shell am start -n 包名/Activity类名</p>
<p>例子：启动应用宝：</p>
<p>adb shell am start -n com.tencent.android.qqdownloader/com.tencent.assistant.activity.SplashActivity</p>
<p>指定模拟器启动动应用宝：</p>
<p>adb -s 127.0.0.1:5555 shell am start -n com.tencent.android.qqdownloader/com.tencent.assistant.activity.SplashActivity</p>
<p>7、关闭应用</p>
<p>adb shell am force-stop 包名</p>
<p>8、模拟输入</p>
<p>adb shell input text 字符串(不支持中文)</p>
<p>9、模拟按键</p>
<p>adb shell input keyevent 键值</p>
<p>10、模拟鼠标点击</p>
<p>adb shell input tap X Y</p>
<p>11、模拟鼠标滑动</p>
<p>adb shell input swipe X1 Y1 X2 Y2</p>
<p>12、截屏</p>
<p>adb shell screencap -p /sdcard/screencap.png</p>
<p>13、设置手机IMEI/IMSI/手机号/SIM卡序列号</p>
<p>adb shell setprop persist.nox.modem.imei 352462010682470</p>
<p>adb shell setprop persist.nox.modem.imsi 460000000000000</p>
<p>adb shell setprop persist.nox.modem.phonumber 15605569000</p>
<p>adb shell setprop persist.nox.modem.serial 89860000000000000000</p>
<p>14、nox_adb shell进去然后执行下面的命令修改经纬度</p>
<p>setprop persist.nox.gps.latitude xxx</p>
<p>setprop persist.nox.gps.longitude xxx</p>
<p>15、修改mac地址</p>
<p>setprop persist.nox.wifimac xxx            修改mac地址</p>
<p>setprop persist.nox.modem.phonumber 138111111111     手机号，生成一个随机11位数字</p>
<p>setprop persist.nox.model ABC001            手机型号，英文加数字随机</p>
<p>setprop persist.nox.manufacturer XiaoMi        手机制造商英文随机</p>
<p>setprop persist.nox.brand Mi             手机品牌英文随机</p>
<p>16、adb logcat</p>
<p>打印log信息</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>adb logcat</td>
<td>打印log</td>
<td>/</td>
</tr>
<tr>
<td>adb logcat -c</td>
<td>清除手机的log buffer</td>
<td>有些手机权限控制, 不支持.</td>
</tr>
<tr>
<td>adb logcat -b &lt;buffer&gt;</td>
<td>打印指定buffer的log信息</td>
<td>buffer有: main(主log区,默认), events(事件相关的log), radio(射频, telephony相关的log)</td>
</tr>
<tr>
<td>adb logcat -v &lt;format&gt;</td>
<td>格式化输出log</td>
<td>常用的用adb logcat -v time显示时间</td>
</tr>
<tr>
<td>adb logcat -f &lt;filename&gt;</td>
<td>输出log到指定文件</td>
<td></td>
</tr>
</tbody></table>
<p>17、adb start/kill-server</p>
<p>启动/杀死adb简介中提到的Server端进程。</p>
<p>由于adb并不稳定, 有时候莫名的问题掉线时, 可以先kill-server, 然后start-server来确保Server进程启动。往往可以解决问题。</p>
<p>18、adb shell am</p>
<p>am即activity manager.<br>该命令用来执行一些系统动作, 例如启动指定activity, 结束进程, 发送广播, 更改屏幕属性等. 调试利器.</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>start &lt;Intent&gt;</td>
<td>根据intent指向启动Activity</td>
<td>Intent可以是显示的指向activity, 也可以是ACTION方式, 并且可以添加flag, data等参数信息.</td>
</tr>
<tr>
<td>startservice &lt;Intent&gt;</td>
<td>启动Service</td>
<td>可以添加flag, data等参数信息.</td>
</tr>
<tr>
<td>broadcast &lt;Intent&gt;</td>
<td>发送广播</td>
<td>可以添加flag, data等参数信息.</td>
</tr>
<tr>
<td>monitor</td>
<td>启动一个Crash和ANR的监听器</td>
<td>如有Crash或ANR会在控制台输出相关信息.</td>
</tr>
<tr>
<td>force-stop &lt;Package&gt;</td>
<td>强制停止该包相关的一切</td>
<td>传入package name.</td>
</tr>
<tr>
<td>kill &lt;Package&gt;</td>
<td>杀死该包相关的所有进程</td>
<td>传入package name.</td>
</tr>
<tr>
<td>kill-all</td>
<td>杀死所有后台进程</td>
<td></td>
</tr>
<tr>
<td>display-size WxH</td>
<td>改变显示的分辨率</td>
<td>例如adb shell am display-size 1280x720, 手机可能不支持.</td>
</tr>
<tr>
<td>display-density &lt;dpi&gt;</td>
<td>改变显示的density</td>
<td>例如adb shell am display-density 320, 手机可能不支持.</td>
</tr>
</tbody></table>
<p>19、adb shell dumpsys</p>
<p>强大的dump工具, 可以输出很多系统信息. 例如window, activity, task/back stack信息, wifi信息等.</p>
<p>常用dumpsys:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>备注</th>
<th>细分参数</th>
</tr>
</thead>
<tbody><tr>
<td>activity</td>
<td>输出app组件相关信息</td>
<td>还可以用细分参数获得单项内容, 下同. 例如adb shell dumpsys activity activities来获取activity task/back stack信息.</td>
<td>activites, service, providers, intents, broadcasts, processes</td>
</tr>
<tr>
<td>alarm</td>
<td>输出当前系统的alarm信息</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>cpuinfo</td>
<td>输出当前的CPU使用情况</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>diskstats</td>
<td>输出当前的磁盘使用状态</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>batterystats</td>
<td>电池使用信息</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>package</td>
<td>package相关信息, 相当于pm功能的集合</td>
<td>输出诸如libs, features, packages等信息</td>
<td>/</td>
</tr>
<tr>
<td>meminfo</td>
<td>输出每个App的内存使用和系统内存状态</td>
<td>可以指定包名, 例如adb shell dumpsys meminfo com.anly.githubapp</td>
<td>/</td>
</tr>
<tr>
<td>window</td>
<td>输出当前窗口相关信息</td>
<td>/</td>
<td>policy, animator, tokens, windows</td>
</tr>
</tbody></table>
<p>20.复制 -copy:<nox_id> _from:<nox_id>例：Nox.exe -copy:Nox_1 -from:nox<br>Nox_1是新增的模拟器，复制自nox</p>
<p>21.删除 -remove:<nox_id><br>例：Nox.exe -remove:Nox_2<br>删除模拟器Nox_2</p>
<p>22.备份 -backup:<nox_id> -file:filepath<br>例：Nox.exe -backup:Nox_1 -file:C:UsersxxxxDesktop<br>备份Nox_1到桌面</p>
<p>23.还原 -restore:<nox_id> -file:filepath<br>例：Nox.exe -restore:Nox_1 -file:C:xxxxlihcDesktopbackup20171030174008.vmdk<br>[C:UsersxxxxDesktopbackup20171030174008.vmdk]文件还原到Nox_1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/01/adb%E5%91%BD%E4%BB%A4/" data-id="ckt188ghs00006wty6vp7acqo" data-title="adb命令" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-移动端测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-09-01T07:49:01.000Z" itemprop="datePublished">2021-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95/">移动端测试概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-移动端操作系统与app类型"><a href="#1-移动端操作系统与app类型" class="headerlink" title="1.移动端操作系统与app类型"></a>1.<strong>移动端操作系统与app类型</strong></h1><h3 id="主流"><a href="#主流" class="headerlink" title="主流"></a><strong>主流</strong></h3><p>Andriod、iOS</p>
<h3 id="非主流"><a href="#非主流" class="headerlink" title="非主流"></a><strong>非主流</strong></h3><p>Winphone、黑莓、塞班、ubuntu、Asha、Tizen、Jolla、Firefox OS、鸿蒙os</p>
<h3 id="非智能机"><a href="#非智能机" class="headerlink" title="非智能机"></a><strong>非智能机</strong></h3><p>MTK平台、S40平台</p>
<h1 id="2-app测试框架介绍"><a href="#2-app测试框架介绍" class="headerlink" title="2.app测试框架介绍"></a>2.<strong>app</strong>测试框架介绍</h1><h2 id="1-Andriod："><a href="#1-Andriod：" class="headerlink" title="1. Andriod："></a>1. <strong>Andriod</strong>：</h2><h3 id="Monkey"><a href="#Monkey" class="headerlink" title="Monkey"></a><strong>Monkey</strong></h3><p>​    Monkey是一个程序，运行在您的模拟器或设备上，并生成伪随机的用户事件流，如点击，触摸或手势，以及一些系统级事件。 您可以使用Monkey以随机但可重复的方式对您正在开发的应用程序进行压力测试。</p>
<h3 id="MonkeyRunner"><a href="#MonkeyRunner" class="headerlink" title="MonkeyRunner"></a><strong>MonkeyRunner</strong></h3><p>​    MonkeyRunner工具是使用Jython(使用Java编程语言实现的Python)写出来的，它提供了多个API，通过monkeyrunner API 可以写一个Python的程序来模拟操作控制Android设备app,测试其稳定性并通过截屏可以方便地记录出现的问题。</p>
<h3 id="UIAutomator"><a href="#UIAutomator" class="headerlink" title="UIAutomator"></a><strong>UIAutomator</strong></h3><p>​    Android 4.3发布的时候包含了一种新的测试工具–uiautomator，uiautomator是用来做UI测试的。也就是普通的手工测试，点击每个控件元素 看看输出的结果是否符合预期。比如 登陆界面 分别输入正确和错误的用户名密码然后点击登陆按钮看看是否能否登陆以及是否有错误提示等。</p>
<h3 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a><strong>Appium</strong></h3><p>​    Appium是一个开源的、跨平台的自动化测试工具，支持IOS、Android和FirefoxOS平台。 通过Appium，开发者无需重新编译app或者做任何调整，就可以测试移动应用，可以使测试代码访问后端API和数据库。</p>
<p>​    它是通过驱动苹果的UIAutomation和Android的UiAutomator框架来实现的双平台支持，同时绑定了Selenium WebDriver用于老的Android平台测试。开发者可以使用WebDriver兼容的任何语言编写测试脚本，如Java， OC， JS， PHP，Python， Ruby， C#，Clojure 和Perl语言。</p>
<h2 id="2-ios"><a href="#2-ios" class="headerlink" title="2.ios"></a>2.ios</h2><h3 id="XCTest"><a href="#XCTest" class="headerlink" title="XCTest"></a><strong>XCTest</strong></h3><p>​        XCTest是苹果在iOS 7和Xcode5引入的一个简单而强大的测试框架，它的测试编写起来非常简单，并且遵循xUnit风格。XCTest的优点是与Xcode深度集成，有专门的Test导航栏，但因为受限于官方测试API，因此功能不是很丰富。</p>
<h3 id="UIAutomation"><a href="#UIAutomation" class="headerlink" title="UIAutomation"></a><strong>UIAutomation</strong></h3><p>​        UIAutomation是苹果提供的UI自动化测试框架，使用Javascript编写。基于UIAutomation有扩展型的工具框架和驱动型的框架。</p>
<p>​        扩展型框架以JavaScript扩展库方法提供了很多好用js工具，注入式的框架通常会提供一些Lib或者是Framework，要求测试人员在待测应用的代码工程中导入这些内容，框架可以通过他们完成对app的驱动。</p>
<p>​        驱动型UI Automation 在自动化测试底层使用了UI Automation库，通过TCP通信的方式驱动UI Automation来完成自动化测试，通过这种方式，编辑脚本的语言不再局限于JavaScript。</p>
<h3 id="Appium-1"><a href="#Appium-1" class="headerlink" title="Appium"></a><strong>Appium</strong></h3><p>​        它是通过驱动苹果的UIAutomation来执行自动化</p>
<h1 id="3-Android-app-类型"><a href="#3-Android-app-类型" class="headerlink" title="3.Android app 类型"></a>3.Android app 类型</h1><h2 id="1-原生应用程序：（Native-App）"><a href="#1-原生应用程序：（Native-App）" class="headerlink" title="1. 原生应用程序：（Native App）"></a>1. <strong>原生应用程序：（Native App）</strong></h2><p>原生APP是什么？原生APP就是利用Android、iOS平台官方的开发语言、开发类库、工具进行开发。比如安卓的java语言，iOS的object-c 语言。在应用性能上和交互体验上应该是最好的。</p>
<p>优点：</p>
<p>1、可访问手机所有功能、可实现功能最齐全；</p>
<p>2、运行速度快、性能高，绝佳的用户体验；</p>
<p>3、支持大量图形和动画。不卡，反应快。</p>
<p>4、比较快捷地使用设备端提供的接口，处理速度上有优势。</p>
<p>缺点：</p>
<p>\1. 在过去主要是成本高、周期长，Android和iOS都需要单独开发。</p>
<p>\2. 更新版本需要重新下载安装包。</p>
<h2 id="2-混合应用程序（Hybrid-App）"><a href="#2-混合应用程序（Hybrid-App）" class="headerlink" title="2. 混合应用程序（Hybrid App）"></a>2. <strong>混合应用程序（Hybrid App）</strong></h2><p>即利用了原生APP的开发技术还应用了HTML5开发技术，是原生和HTML5技术的混合应用。混合比例不限。</p>
<p>优点：</p>
<p>1、开发周期短；</p>
<p>2、功能更新发布快；</p>
<p>缺点：</p>
<p>1、用户体验不如本地应用；</p>
<p>2、性能稍慢（需要连接网络）；</p>
<h2 id="3-Web版APP-（Web-App）"><a href="#3-Web版APP-（Web-App）" class="headerlink" title="3. Web版APP （Web App）"></a>3. <strong>Web版APP （Web App）</strong></h2><p>本质就是浏览器功能的叠加，用普通Web开发语言开发的，通过浏览器运行。</p>
<p>优势：</p>
<p>1、支持范围广；</p>
<p>2、开发成本低、周期短。</p>
<p>缺点：</p>
<p>1、对联网要求高，离线不能做任何操作；</p>
<p>2、功能有限；</p>
<p>3、运行速度慢，页面不能承载太多东西；</p>
<p>4、图片和动画支持性不高；</p>
<p>5、如果用户使用更多的新型浏览器，那么就会出现运行问题。</p>
<h2 id="4-Web-App、Hybrid-App、Native-App-技术特性"><a href="#4-Web-App、Hybrid-App、Native-App-技术特性" class="headerlink" title="4. Web App、Hybrid App、Native App 技术特性"></a>4. <strong>Web App、Hybrid App、Native App 技术特性</strong></h2><p><img src="https://pic.imgdb.cn/item/612f324a44eaada739a14efd.jpg"></p>
<h2 id="5-手游app与手机App"><a href="#5-手游app与手机App" class="headerlink" title="5. 手游app与手机App"></a>5. <strong>手游app与手机App</strong></h2><p>手游一般使用引擎开发，现在著名的有cocos2d和unity3d。两者都是使用引擎自带的语言进行开发，主流的分别是c++和c#，虽然在开发过程中也有按钮等控件的概念，但当运行时由引擎渲染后就变成了一副简单的图片：</p>
<p>手机App一般使用Android SDK开发，使用Java编写。通过Android提供的服务，我们可以获取App当前窗口的视图信息，进而查找和操作按钮等控件，以完成自动化测试，如Uiautomator。这个过程是标准化的，从技术上来说没有任何难度，因此各个公司各个App自动化测试的方法都大同小异。</p>
<h1 id="4-Android-SDK介绍"><a href="#4-Android-SDK介绍" class="headerlink" title="4.Android    SDK介绍"></a>4.<strong>Android</strong>    <strong>SDK介绍</strong></h1><p>SDK：（software development kit）软件开发工具包。被软件开发工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。</p>
<p>因此，Android SDK 指的是Android专属的软件开发工具包。</p>
<h1 id="5-Android-SDK环境搭建"><a href="#5-Android-SDK环境搭建" class="headerlink" title="5.Android SDK环境搭建"></a>5.<strong>Android SDK环境搭建</strong></h1><h2 id="1-配置jdk环境"><a href="#1-配置jdk环境" class="headerlink" title="1. 配置jdk环境"></a>1. <strong>配置</strong>jdk环境</h2><p>因为安卓用Java语言开发，所以安装安卓环境——首先需要安装配置好jdk环境。</p>
<p><strong>推荐使用jdk 8以上的版本</strong></p>
<h2 id="2-SDK下载"><a href="#2-SDK下载" class="headerlink" title="2. SDK下载"></a>2. <strong>SDK下载</strong></h2><p>Android SDK包下载</p>
<ul>
<li>官网下载：<a target="_blank" rel="noopener" href="https://android-sdk.en.softonic.com/download">https://android-sdk.en.softonic.com/download</a></li>
<li>网盘下载： <a target="_blank" rel="noopener" href="http://tools.android-studio.org/index.php/sdk">http://tools.android-studio.org/index.php/sdk</a></li>
</ul>
<p>安装后启动 SDK Manager.exe 程序就可以看到Android SDK Mannerger的主界面。</p>
<h3 id="Tools目录："><a href="#Tools目录：" class="headerlink" title="Tools目录："></a><strong>Tools目录：</strong></h3><p><strong>Android SDK Tools</strong>（必须，只需下载一个版本，一般选最新版本）：基础工具包，版本号带rc字样的是预览版。</p>
<p><strong>Android SDK Platform-tools</strong>（必须，只需下载一个版本，一般选最新版本）：从android2.3开始划出此目录，存放公用开发工具，比如adb、sqlite3等，被划分到了这里。</p>
<p><strong>Android SDK Build-tools</strong>（必须，可以安装多个版本）：Android项目构建工具。</p>
<h3 id="Android-xxx（API-xx）目录（可选的各平台开发工具）："><a href="#Android-xxx（API-xx）目录（可选的各平台开发工具）：" class="headerlink" title="Android xxx（API xx）目录（可选的各平台开发工具）："></a>Android xxx（API xx）目录（可选的各平台开发工具）：</h3><p><img src="file:///C:\Users\adm\AppData\Local\Temp\ksohtml4312\wps3.jpg" alt="img"> </p>
<p>· Documentation for AndroidSdk（可选）：安卓开发者官网的一些离线文档，不过下载下来打开也很慢，后面会提供另外一个离线版。</p>
<p><strong>SDK Platform</strong>（必须）：对应平台的开发工具，需要在哪个版本的平台下开发就下载哪个。</p>
<p>· Samples for SDK（可选，此项在高版本tools中已不提供，需要在IDE里通过Import Sample引入，当然也可以下载离线版）：内置的安卓示例程序，推荐安装。</p>
<p>· Sources for Android SDK（可选）：安卓API的源代码，推荐安装。</p>
<p>· ARM /Intel xxxx Image（可选）：各个以Image结尾的东西是支持相应平台的模拟器，我们就把它想象成一个刷机包吧。（使用真机调试或使用其它模拟器的话不需要安装）</p>
<p>Extras目录（可选的扩展）：</p>
<p><img src="file:///C:\Users\adm\AppData\Local\Temp\ksohtml4312\wps4.jpg" alt="img"> </p>
<p>· Android Support Repository（可选）：主要是方便在gradle中使用Android Support Libraries，因为Google并没有把这些库发布到maven center或者jcenter去，而是使用了Google自己的maven仓库。</p>
<p>· Intel x86 Emulator Accelerator(HAXM installer)（可选）：windows平台的Intel x86模拟器加速工具，配合Intel x86 atom/atom_64 System Image使用可加快模拟器的运行速度。</p>
<h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a><strong>环境变量设置</strong></h2><p>· 系统变量里面添加变量名 ANDROID_HOME 路径为实际存放SDk的路径</p>
<h1 id="6。monkey"><a href="#6。monkey" class="headerlink" title="6。monkey"></a><strong>6。monkey</strong></h1><h2 id="一、Monkey简介"><a href="#一、Monkey简介" class="headerlink" title="一、Monkey简介"></a>一、<strong>Monkey简介</strong></h2><p>在Android的官方自动化测试领域有一只非常著名的“猴子”叫Monkey，这只“猴子”一旦启动，就会让被测的Android应用程序像猴子一样活蹦乱跳，到处乱跑。人们常用这只“猴子”来对被测程序进行压力测试，检查和评估被测程序的稳定性。</p>
<p>Android官方对这只“猴子”的描述是这样的：</p>
<p>The Monkey is a program that runs on your emulator or device and generates pseudo-random streams of user events such as clicks, touches, or gestures, as well as a number of system-level events. You can use the Monkey to stress-test applications that you are developing, in a random yet repeatable manner.</p>
<p>Monkey是一个程序，运行在您的模拟器或设备上，并生成伪随机的用户事件流，如点击，触摸或手势，以及一些系统级事件。 您可以使用Monkey以随机但可重复的方式对您正在开发的应用程序进行压力测试。</p>
<p>monkey官方文档：<a target="_blank" rel="noopener" href="http://www.android-doc.com/tools/help/monkey.html">http://www.android-doc.com/tools/help/monkey.html</a></p>
<h2 id="二、Moneky-路径"><a href="#二、Moneky-路径" class="headerlink" title="二、Moneky 路径"></a>二、<strong>Moneky 路径</strong></h2><p>Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的Monkey文件，其jar包是位于Android系统的/system/framework目录的Monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。同时，Monkey还会对测试系统进行监测，当出现以下三种情况时会进行特殊处理：</p>
<p>· 如限定了Monkey运行在特定包上，当监测到试图转到其他包的操作，将对其进行阻止。</p>
<p>· 如应用程序崩溃或接收到任何失控异常，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</p>
<p>· 如果应用程序发生了程序无响应（application not responding）的错误，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</p>
<p>· 按照选定的不同级别的反馈信息，在Monkey中还可以看到其执行过程报告和生成的事件。</p>
<h2 id="三、Monkey启动步骤"><a href="#三、Monkey启动步骤" class="headerlink" title="三、Monkey启动步骤"></a>三、<strong>Monkey启动步骤</strong></h2><ol>
<li><p>连接模拟器</p>
</li>
<li><p>连接成功后输入命令</p>
</li>
</ol>
<p><code>adb shell</code></p>
<h2 id="四、进入到指定目录"><a href="#四、进入到指定目录" class="headerlink" title="四、进入到指定目录"></a>四、<strong>进入到指定目录</strong></h2><p><code>cd /system/bin</code></p>
<ol start="3">
<li>输入 monkey命令看到提示则说明启动成功。</li>
</ol>
<h2 id="五、强制关闭monkey"><a href="#五、强制关闭monkey" class="headerlink" title="五、强制关闭monkey"></a>五、<strong>强制关闭monkey</strong></h2><ol>
<li><p>adb shell ps 查看全部在运行的进程</p>
</li>
<li><p>查找出com.android.commands.monkey 进程PID</p>
</li>
<li><p>adb shell kill pid 杀掉monkey进程</p>
</li>
</ol>
<h2 id="六、monkey-命令"><a href="#六、monkey-命令" class="headerlink" title="六、monkey 命令"></a>六、<strong>monkey 命令</strong></h2><p>monkey命令格式如下：</p>
<p><code>$ adb shell monkey [options] &lt;event-count&gt;</code></p>
<p><strong>·</strong> <strong>[options]</strong> 是指monkey可传入的参数，是<strong>可选项</strong>（如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包）</p>
<p>·<strong>&lt;event-count&gt;</strong> 是指随机发送事件数。如：输入100就是执行100个伪随机事件，为<strong>必选项</strong>。</p>
<h2 id="七、操作事件简介"><a href="#七、操作事件简介" class="headerlink" title="七、操作事件简介"></a>七、<strong>操作事件简介</strong></h2><p>Monkey所执行的随机事件流中包含11大事件，分别是触摸事件、手势事件、二指缩放事件、轨迹事件、屏幕旋转事件、基本导航事件、主要导航事件、系统按键事件、启动Activity事件、键盘事件、其他类型事件。Monkey通过这11大事件来模拟用户的常规操作，对手机App进行稳定性测试。下面让我们来详细了解这11大事件。</p>
<h3 id="1-触摸事件"><a href="#1-触摸事件" class="headerlink" title="1.触摸事件"></a><strong>1.触摸事件</strong></h3><p>触摸事件是指在屏幕某处按下并抬起的操作，可通过***–pct-touch***参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到。 该事件由一组Touch（ACTION_DOWN）和Touch（ACTION_UP）事件组成，在手机上看到实际操作类似于点击。</p>
<h3 id="2-手势事件"><a href="#2-手势事件" class="headerlink" title="2.手势事件"></a><strong>2.手势事件</strong></h3><p>手势事件是指在屏幕某处的按下、随机移动、抬起的操作，即直线滑动操作。可通过***–pct-motion***参数来配置其事件百分比。</p>
<p>该事件是由一个ACTION_DOWN事件、一系列ACTION_MOVE事件和一个ACTION_UP事件组成的，在手机上看到的实际操作是一个没有拐弯的直线滑动操作。</p>
<h3 id="3-二指缩放事件"><a href="#3-二指缩放事件" class="headerlink" title="3.二指缩放事件"></a><strong>3.二指缩放事件</strong></h3><p>二指缩放事件是指在屏幕上的两处同时按下，并同时移动，最后同时抬起的操作，即智能机上的放大缩小手势操作。可通过–pct-pinchzoom参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p>该事件起始是一个ACTION_DOWN事件和一个ACTION_POINTER_DOWN事件，即模拟两个手指同时点下；中间是一系列的ACTION_MOVE事件，即两个手指同时在屏幕上直线滑动；结束是由一个ACTION_POINTER_UP事件和一个ACTION_UP事件组成的，即两个手指同时放开。</p>
<h3 id="4-轨迹事件"><a href="#4-轨迹事件" class="headerlink" title="4.轨迹事件"></a><strong>4.轨迹事件</strong></h3><p>轨迹事件是由一个或多个随机的移动组成的，有时会伴随着点击。很早之前的Android手机带有轨迹球，这个事件就是模拟的轨迹球的操作。现在的手机几乎都没有轨迹球，但轨迹球事件中包含曲线滑动操作，如果被测程序需要曲线滑动时可以选用此参数。可通过–pct-trackball参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p>该事件是由一系列的Trackball（ACTION_MOVE）事件组成的，观察手机上的操作，即为一系列的曲线滑动操作。</p>
<h3 id="5-屏幕旋转事件"><a href="#5-屏幕旋转事件" class="headerlink" title="5.屏幕旋转事件"></a><strong>5.屏幕旋转事件</strong></h3><p>屏幕旋转事件是一个隐藏事件，在Android官方文档中并没有记录这个事件。它其实是模拟的Android手机的横屏和竖屏切换。可通过–pct-rotation参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件由一个rotation事件组成，其中degree表示的是旋转方向，顺时针旋转，0表示旋转90度的方向，1表示旋转180度的方向，2表示旋转270度的方向，3表示旋转360度的方向。在执行过程中，可以看到手机屏幕在横竖屏之间不断地切换。</p>
<h3 id="6-基本导航事件"><a href="#6-基本导航事件" class="headerlink" title="6.基本导航事件"></a><strong>6.基本导航事件</strong></h3><p>基本导航事件是指点击方向输入设备的上、下、左、右按键的操作，现在手机上很少有上、下、左、右按键，这种事件一般用得比较少。可通过–pct-nav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到：</p>
<p>该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上、下、左、右四个方向按键。</p>
<h3 id="7-主要导航事件"><a href="#7-主要导航事件" class="headerlink" title="7.主要导航事件"></a><strong>7.主要导航事件</strong></h3><p>主要导航事件是指点击“主要导航”按键的操作，这些按键通常会导致UI界面中的动作，如键盘的中间键、回退按键、菜单按键。可通过–pct-majornav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是中间键和菜单键。</p>
<h3 id="8-系统按键事件"><a href="#8-系统按键事件" class="headerlink" title="8.系统按键事件"></a><strong>8.系统按键事件</strong></h3><p>系统按键事件是指点击系统保留使用的按键的操作，如点击Home键、返回键、音量调节键等。可通过–pct-syskeys参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的就是上面说到的几个系统按键。</p>
<h3 id="9-启动Activity事件"><a href="#9-启动Activity事件" class="headerlink" title="9.启动Activity事件"></a><strong>9.启动Activity事件</strong></h3><p>启动Activity事件是指在手机上启动一个Activity的操作。在随机的时间间隔中，Monkey将执行一个startActivity（）方法，作为最大限度上覆盖被测包中全部Activity的一种方法。可通过–pct-appswitch参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Switch操作组成的，从手机上看，上面的操作实际是打开了com.android.settings这个应用的一个com.android.settings.Settings的Activity界面。</p>
<h3 id="10-键盘事件"><a href="#10-键盘事件" class="headerlink" title="10.键盘事件"></a><strong>10.键盘事件</strong></h3><p>键盘事件主要是一些与键盘相关的操作。比如点击输入框、键盘弹起、点击输入框以外区域、键盘收回等。可通过–pct-flip参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 如日志所示，这里主要是键盘的打开和关闭操作。</p>
<h3 id="11-其他类型事件"><a href="#11-其他类型事件" class="headerlink" title="11.其他类型事件"></a><strong>11.其他类型事件</strong></h3><p>其他类型事件包括了除前面提到的10种事件外其他所有的事件，如按键、其他不常用的设备上的按钮等。可通过–pct-anyevent参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到： [代码] 该事件是由一个Key（ACTION_DOWN）和一个Key（ACTION_UP）组成的，点击的按键就是其他的一些系统按键，如字母按键、数字按键等。因为现在手机很少带字母按键或数字按键，所以这个事件一般使用得比较少。</p>
<h1 id="八、monkey-参数"><a href="#八、monkey-参数" class="headerlink" title="八、monkey 参数"></a>八、<strong>monkey 参数</strong></h1><h3 id="1-参数分类"><a href="#1-参数分类" class="headerlink" title="1. 参数分类"></a>1. <strong>参数分类</strong></h3><p>· 常规类参数</p>
<p>· 事件类参数</p>
<p>· 约束类参数</p>
<p>· 调试类参数</p>
<h3 id="2-常规类参数"><a href="#2-常规类参数" class="headerlink" title="2. 常规类参数"></a>2. <strong>常规类参数</strong></h3><p>常规类参数包括帮助参数和日志信息参数。帮助参数用于输出Monkey命令使用指导；日志信息参数将日志分为三个级别，级别越高，日志的信息越详细。</p>
<p>1.帮助类参数</p>
<p>monkey -h</p>
<p>2.日志级别</p>
<p><code>$ adb shell monkey -v &lt;event-count&gt;</code></p>
<p>-v：打印出日志信息，每个-v将增加反馈信息的级别。-v越多日志信息越详细，不过目前最多支持3个-v，即：</p>
<p><img src="https://pic.imgdb.cn/item/61373a5744eaada739c3d3e0.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/61373a6744eaada739c3eef3.jpg"></p>
<h3 id="3-事件类参数"><a href="#3-事件类参数" class="headerlink" title="3. 事件类参数"></a>3. <strong>事件类参数</strong></h3><p>事件类参数的作用是对随机事件进行调控，从而使其遵照设定运行，如设置各种事件的百分比、设置事件生成所使用的种子值等。频率参数主要限制事件执行的时间间隔。</p>
<p>1.执行指定脚本</p>
<p><code>$ adb shell monkey -f &lt;scriptfile&gt; &lt;event-count&gt;</code></p>
<p>eg：</p>
<p><code>$ adb shell monkey -f /mnt/sdcard/test1</code></p>
<p>2.伪随机数生成种子值</p>
<p>使用 -s命令可以重复执行之前的伪随机操作。本身每次执行伪随机事件操作也会默认生成一个seed值</p>
<p><code>$ adb shell monkey -s &lt;seed&gt; &lt;event-count&gt;</code></p>
<p>eg:</p>
<p><code>$ adb shell monkey -s 666 100</code></p>
<p>3.设置间隔 如果你希望在每一个指令之间加上固定的间隔时间，可以用–throttle（注意，前面是–）命令。</p>
<p><code>$ adb shell monkey --throttle &lt;milliseconds&gt;</code></p>
<p>eg:</p>
<p><code>$ adb shell monkey --throttle 3000  5</code></p>
<p>–throttle：后面接时间，单位为ms（&lt;milliseconds&gt;），表示事件之间的固定延迟（即执行每一个指令间隔的时间），若不接该选项，monkey将不会延迟。</p>
<p>4.调整触摸事件百分比</p>
<p>如果你希望调整触摸事件的百分比，记住使用–pct-touch。</p>
<p><code>$ adb shell monkey --pct-touch</code></p>
<p>eg:</p>
<p><code>$ adb shell monkey -v -v --pct-touch 100 200</code></p>
<p>&lt;percent&gt;–pct-touch：后面接触摸事件百分比</p>
<p>注意：触摸事件不单单是按键，它泛指发生在某一位置的一个down-up事件。</p>
<p>5.调整手势事件百分比</p>
<p><code>$ adb shell monkey --pct-motion</code></p>
<p>eg:</p>
<p><code>$ adb shell monkey -v -v --pct-motion 100 200</code></p>
<p>6.调整应用启动事件的百分比</p>
<p>如果你希望调整应用启动事件的百分比，记住使用–pct-app-switch。</p>
<p><code>$ adb shell monkey --pct-appswtich &lt;percent&gt;</code></p>
<p>–pct-appswitch：后面接应用启动事件百分比。</p>
<p>应用启动事件（即activity launches）俗称打开应用，通过调用startActivity()方法最大限度地开启该package下的所有应用。</p>
<p>7.调整屏幕旋转事件百分比</p>
<p><code>$ adb shell monkey --pct-rotation &lt;percent&gt;</code></p>
<p>–pct-rotation 后面接屏幕旋转事件的比例值。</p>
<p>8.其他参数</p>
<p><img src="https://pic.imgdb.cn/item/612f39d144eaada739af24b5.jpg"></p>
<h3 id="4-约束类参数"><a href="#4-约束类参数" class="headerlink" title="4. 约束类参数"></a>4. <strong>约束类参数</strong></h3><p><em><strong>1.包约束</strong></em></p>
<p>-p：后面接一个或多个包名（&lt;allowed-package-name&gt;），如果应用需要访问其他包里的Activity，那相关的包也需要在此同时指定。如果不指定任何包，monkey将允许系统启动全部包里的Activity。</p>
<p><code>$ adb shell monkey -p &lt;allowed-package-name&gt; &lt;event-count&gt;</code></p>
<p>eg：</p>
<p><code>$ adb shell monkey -p com.tal.kaoyan 500</code></p>
<p><code>$ adb shell monkey -p com.tal.kaoyan -p com.tencent.mm 500</code></p>
<p><em><strong>2.activity类约束</strong></em></p>
<p>如果你希望将monkey限制在一个或几个类别中，使用如下命令：</p>
<p><code>adb shell monkey -c &lt;main-category&gt; &lt;event-count&gt;</code></p>
<p>以下命令表示运行Intent.CATEGORY_LAUNCHER类别的Activity并发送1000个随机事件。</p>
<p><code>$ adb shell monkey -c Intent.CATEGORY_LAUNCHER  1000</code></p>
<p><img src="https://pic.imgdb.cn/item/61373b6e44eaada739c58cfd.jpg"></p>
<h3 id="5-调试类参数"><a href="#5-调试类参数" class="headerlink" title="5. 调试类参数"></a>5. <strong>调试类参数</strong></h3><p><em><strong>1.应用程序崩溃后继续发送事件</strong></em></p>
<p>如果你希望monkey在应用程序崩溃后继续发送事件，则需要用到–ignore-crashes命令</p>
<p><code>$ adb shell monkey --ignore-crashes &lt;event-count&gt; </code></p>
<p>在设置此选项后，当应用程序崩溃或发生失控异常时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到上述崩溃或异常将停止运行。</p>
<p><em><strong>2.超时错误继续发送事件</strong></em></p>
<p>如果你希望monkey在任何超时错误发生后继续发送事件，则需要用到–ignore-timeouts命令。</p>
<p><code>$ adb shell monkey --ignore-timeouts</code></p>
<p>&lt;event-count&gt;–ignore-timeouts：在设置此选项后，当应用程序发生任何超时错误（如ANR，即Application Not Responding）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类超时对话框将停止运行。</p>
<p><em><strong>3.应用程序权限错误发生后继续发送事件</strong></em></p>
<p>如果你希望monkey在应用程序权限错误发生后继续发送事件，则需要用到–ignore-security-exceptions命令。</p>
<p><code>$ adb shell monkey --ignore-security-exceptions</code></p>
<p>&lt;event-count&gt;–ignore-security-exceptions：在设置此选项后，当应用程序发生任何权限错误（如启动一个需要某些权限的Activity）时，monkey将继续运行直到计数完成。如果不设置此选项，monkey遇到此类权限错误将停止运行。</p>
<p>4.其他</p>
<p><img src="https://pic.imgdb.cn/item/612f3b1544eaada739b12a44.jpg"></p>
<h1 id="九、Monkey参数应用综合案例"><a href="#九、Monkey参数应用综合案例" class="headerlink" title="九、Monkey参数应用综合案例"></a>九、<strong>Monkey参数应用综合案例</strong></h1><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a><strong>测试场景</strong></h3><p>测试考研帮app Android版。测试希望通过Monkey来模拟用户的随机操作，检查被测应用是否会出现异常（应用崩溃或者无响应）。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h3><p>1、测试是指定应用，因此需要使用-p指定被测app包名：com.tal.kaoyan</p>
<p>2、这个测试的目的是希望模拟用户操作，因此需要让Monkey执行的事件尽可能地接近用户的常规操作，这样才可以最大限度地发现用户使用过程中可能出现的问题。因此需要对Monkey执行的事件百分比做一些调整:</p>
<p>触摸事件和手势事件是用户最常见的操作，所以通过–pct-touch和–pct-motion将这两个事件的占比调整到40%与25%；目标应用包含了多个Activity，为了能覆盖大部分的Activity，所以通过–pct-appswitch将Activity切换的事件占比调整到10%；被测应用在测试中出现过不少横竖屏之间切换的问题，这个场景也必须关注，因此通过–pct-rotation把横竖屏切换事件调整到10%。</p>
<p>3、使用-s参数来指定命令执行的seed值 Monkey会根据seed值来生成对应事件流，同一个seed生成的事件流是完全相同的。这里指定了seed值，是为了测试发现问题时，便于进行问题复现。</p>
<p>4、使用–throttle参数来控制Monkey每个操作之间的时间间隔 指定操作之间的时间间隔，一方面是希望能更接近用户的操作场景，正常用户操作都会有一定的时间间隔；另一方面也是不希望因为过于频繁的操作而导致系统崩溃，尤其是在比较低端的手机上执行测试时。因此通过–throttle设置Monkey每个操作固定延迟0.4秒。</p>
<p>5、使用–ignore-crashs和–ignore-timeouts参数使Monkey遇到意外时能继续执行 在执行Monkey测试时，会因为应用的崩溃或没有响应而意外终止，所以需要在命令中增加限制参数–ignore-crash和–ignore-timeouts，让Monkey在遇到崩溃或没有响应的时候，能在日志中记录相关信息，并继续执行后续的测试。</p>
<p>6、使用-v指定log的详细级别 Monkey的日志输出有3个级别：日志的级别越高，其详细程度也越高。为了方便问题的定位，这里将日志设为 -v -v.</p>
<h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a><strong>测试命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p com.tal.kaoyan</span><br><span class="line">--pct-touch 40 --pct-motion 25 </span><br><span class="line">--pct-appswitch 10</span><br><span class="line">--pct-rotation 5</span><br><span class="line">-s 1666 --throttle 400</span><br><span class="line">--ignore-crashes</span><br><span class="line">--ignore-timeouts</span><br><span class="line">-v -v  200</span><br></pre></td></tr></table></figure>

<h1 id="十、Monkey自定义脚本"><a href="#十、Monkey自定义脚本" class="headerlink" title="十、Monkey自定义脚本"></a>十、Monkey自定义脚本</h1><h4 id="自定义脚本的稳定性测试"><a href="#自定义脚本的稳定性测试" class="headerlink" title="自定义脚本的稳定性测试"></a><strong>自定义脚本的稳定性测试</strong></h4><p>常规Monkey测试执行的是随机的事件流，但如果只是想让Monkey测试某个特定场景这时候就需要用到自定义脚本了，Monkey支持执行用户自定义脚本的测试，用户只需要按照Monkey脚本的规范编写好脚本，存放到手机上，启动Monkey通过-f 参数调用脚本即可。</p>
<h4 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a><strong>测试案例</strong></h4><p>启动考研帮app3.1.0，然后跳过升级提示和引导页面，进入到登录界面并输入用户名密码进行登录。</p>
<h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h4><p>· 从用户角度来思考步骤该怎样进行？</p>
<p>· 要操作的元素该如何定位？</p>
<p>· 怎样将操作步骤转化为测试脚本？</p>
<h5 id="获取元素坐标点位置"><a href="#获取元素坐标点位置" class="headerlink" title="获取元素坐标点位置"></a><em><strong>获取元素坐标点位置</strong></em></h5><p>Monkey脚本只能通过<em><strong>坐标</strong></em>的方式来定位点击和移动事件的屏幕位置，这里就需要提前获取坐标信息。获取坐标信息的方法很多，最简单的方法就是打开手机中的开发人员选项，打开“显示指针位置”。随后，在屏幕上的每次操作，在导航栏上都会显示坐标信息。</p>
<h5 id="Monkey脚本API简介"><a href="#Monkey脚本API简介" class="headerlink" title="Monkey脚本API简介"></a><em><strong>Monkey脚本API简介</strong></em></h5><p>LaunchActivity(pkg_name, cl_name)：启动应用的Activity。参数：包名和启动的Activity。</p>
<p>Tap(x, y, tapDuration)： 模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。</p>
<p>UserWait(sleepTime)： 休眠一段时间</p>
<p>DispatchPress(keyName)： 按键。参数： keycode。 RotateScreen(rotationDegree, persist)： 旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。</p>
<p>DispatchString(input)： 输入字符串。</p>
<p>DispatchFlip(true/false)： 打开或者关闭软键盘。</p>
<p>PressAndHold(x, y, pressDuration)： 模拟长按事件。</p>
<p>Drag(xStart, yStart, xEnd, yEnd, stepCount)： 用于模拟一个拖拽操作。</p>
<p>PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)： 模拟缩放手势。</p>
<p>LongPress()： 长按2秒。</p>
<p>DeviceWakeUp()： 唤醒屏幕。</p>
<p>PowerLog(power_log_type, test_case_status)： 模拟电池电量信息。</p>
<p>WriteLog()： 将电池信息写入sd卡。</p>
<p>RunCmd(cmd)： 运行shell命令。</p>
<p>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)： 向指定位置，发送单个手势。</p>
<p>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)： 发送按键消息。</p>
<p>LaunchInstrumentation(test_name,runner_name)： 运行一个instrumentation测试用例。</p>
<p>DispatchTrackball： 模拟发送轨迹球事件。</p>
<p>ProfileWait： 等待5秒。</p>
<p>StartCaptureFramerate()： 获取帧率。</p>
<p>EndCaptureFramerate(input)： 结束获取帧率。</p>
<h5 id="Monkey脚本格式"><a href="#Monkey脚本格式" class="headerlink" title="Monkey脚本格式"></a><em><strong>Monkey脚本格式</strong></em></h5><p>Monkey脚本主要包含两部分，一部分是头文件信息，一部分是具体的monkey命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type = raw events  </span><br><span class="line"></span><br><span class="line">count = 1  </span><br><span class="line"></span><br><span class="line">speed = 1.0  </span><br><span class="line"></span><br><span class="line">//下面为monkey命令 </span><br><span class="line"></span><br><span class="line">start data &gt;&gt;  </span><br><span class="line"></span><br><span class="line">具体的monkey脚本内容 </span><br></pre></td></tr></table></figure>



<h5 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a><em><strong>编写脚本</strong></em></h5><p>kyb.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#头文件信息</span><br><span class="line"></span><br><span class="line">type = raw events </span><br><span class="line"></span><br><span class="line">count = 1</span><br><span class="line"></span><br><span class="line">speed = 1.0</span><br><span class="line"></span><br><span class="line">#启动测试</span><br><span class="line">start data &gt;&gt;</span><br><span class="line"></span><br><span class="line">LaunchActivity(com.tal.kaoyan,com.tal.kaoyan.ui.activity.SplashActivity)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(624,900,1000) #点击取消升级</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(806,64,1000) #点击跳过</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(217,378,1000) #点击用户名输入框</span><br><span class="line">DispatchString(账户)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(197,461,1000) #点击密码输入框</span><br><span class="line">DispatchString(密码)</span><br><span class="line">UserWait(2000)</span><br><span class="line"></span><br><span class="line">Tap(343,637,1000) #点击登录按钮</span><br></pre></td></tr></table></figure>

<h5 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a><em><strong>执行脚本</strong></em></h5><p>脚本编写完成后，传到手机设备上，然后执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb push C:\Users\admin\Desktop\kyb1.txt /sdcard</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">adb shell monkey -f /sdcard/kyb1.txt -v 1</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin&gt;adb shell monkey -f /sdcard/kyb.txt -v 1</span><br><span class="line">:Monkey: seed=1524592021303 count=1</span><br><span class="line">:IncludeCategory: android.intent.category.LAUNCHER</span><br><span class="line">:IncludeCategory: android.intent.category.MONKEY</span><br><span class="line">Replaying 0 events with speed 1.0</span><br><span class="line">:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.tal.kaoyan/.ui.activity.SplashActivity;end</span><br><span class="line">    // Allowing start of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.tal.kaoyan/.ui.activity.SplashActivity &#125; in package com.tal.kaoyan</span><br><span class="line">:Sending Touch (ACTION_DOWN): 0:(267.0,1233.0)</span><br><span class="line">    // Allowing start of Intent &#123; act=com.android.systemui.recent.action.TOGGLE_RECENTS cmp=com.android.systemui/.recent.RecentsActivity &#125; in package com.android.systemui</span><br><span class="line">:Sending Touch (ACTION_UP): 0:(267.0,1233.0)</span><br><span class="line">Events injected: 5</span><br><span class="line">:Sending rotation degree=0, persist=false</span><br><span class="line">:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0</span><br><span class="line">## Network stats: elapsed time=7201ms (0ms mobile, 0ms wifi, 7201ms not connected)</span><br><span class="line">// Monkey finished</span><br></pre></td></tr></table></figure>



<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><p>头文件代码书写注意“=”两边预留空格，否则会出现如下报错。</p>
<p><code>java.lang.NumberFormatException: Invalid int: &quot;&quot;</code></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mgzc-1508873480/p/7911373.html">https://www.cnblogs.com/mgzc-1508873480/p/7911373.html</a></p>
<h1 id="十一、MonkeyRunner-API"><a href="#十一、MonkeyRunner-API" class="headerlink" title="十一、MonkeyRunner API"></a>十一、MonkeyRunner API</h1><p>MonkeyRunner工具主要有三个类：</p>
<ol>
<li><p>MonkeyRunner</p>
</li>
<li><p>MonkeyDevice</p>
</li>
<li><p>MonkeyImage</p>
</li>
</ol>
<p>官方API文档 ：<a target="_blank" rel="noopener" href="http://www.android-doc.com/tools/help/monkeyrunner_concepts.html">http://www.android-doc.com/tools/help/monkeyrunner_concepts.html#</a></p>
<h3 id="1-MonkeyRunner类："><a href="#1-MonkeyRunner类：" class="headerlink" title="1.MonkeyRunner类："></a><strong>1.MonkeyRunner类：</strong></h3><p>MonkeyRunner提供连接真机和模拟器、输入、暂停、警告框等方法。</p>
<p><img src="https://pic.imgdb.cn/item/61373d7c44eaada739c8ddf5.jpg"></p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h5><p>waitForConnection(float timeout,string deviceid)，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from com.android.monkeyrunner import MonkeyRunner as mr</span><br><span class="line">print(&quot;connect devices...&quot;)</span><br><span class="line"></span><br><span class="line">device=mr.waitForConnection()</span><br><span class="line"># device=mr.waitForConnection(5,&#x27;127.0.0.1:62001&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="2-MonkeyDevice类"><a href="#2-MonkeyDevice类" class="headerlink" title="2.MonkeyDevice类"></a><em><strong>2.MonkeyDevice类</strong></em></h3><p>MonkeyDevice类提供了安装和卸载程序包、开启Activity、发送按键和点击事件、运行测试包等方法。</p>
<p><img src="https://pic.imgdb.cn/item/61373da744eaada739c92549.jpg"></p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><p>· installPackage (string path)</p>
<p>· removePackage (string package)</p>
<p>· startActivity (string uri, string action, string data, string mimetype, iterable categories dictionary extras, component component, flags)</p>
<p>· touch (integer x, integer y, integer type)</p>
<p><em><strong>touch参数说明</strong></em></p>
<p>integer x，x坐标值。<br>integer y，y坐标值。<br>integer type，key event类型（如DOWN、UP、DOWN_AND_UP）。</p>
<p>DOWN为按下事件 UP为弹起事件 DOWN_AND_UP为按下弹起事件。</p>
<p>· drag (tuple start, tuple end, float duration, integer steps)</p>
<p><em><strong>drag参数详细说明如下：</strong></em></p>
<p>tuple start，拖拽起始位置，为tuple类型的(x,y)坐标点。<br>tuple end，拖拽终点位置，为tuple类型的(x,y)坐标点。<br>float duration，拖拽手势持续时间，默认为1.0s。<br>-integer steps，插值点的步数，默认值为10。</p>
<h5 id="实践案例："><a href="#实践案例：" class="headerlink" title="实践案例："></a><em><strong>实践案例：</strong></em></h5><p>连接设备，安装考研帮App并启动</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><em><strong>代码实现</strong></em></h5><p>kyb_start.py</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from com.android.monkeyrunner import MonkeyRunner as mr</span><br><span class="line">from com.android.monkeyrunner import MonkeyDevice as md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;connect devices...&quot;)</span><br><span class="line">device=mr.waitForConnection()</span><br><span class="line"></span><br><span class="line">print(&quot;install app...&quot;)</span><br><span class="line">device.installPackage(r&#x27;C:\Users\admin\Desktop\kaoyan3.1.0.apk&#x27;)</span><br><span class="line"></span><br><span class="line">package = &#x27;com.tal.kaoyan&#x27;</span><br><span class="line">activity = &#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;</span><br><span class="line">runComponent = package + &#x27;/&#x27; + activity</span><br><span class="line"></span><br><span class="line">print(&quot;launch App...&quot;)</span><br><span class="line">device.startActivity(component=runComponent)</span><br></pre></td></tr></table></figure>

<p>代码执行方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">monkeyrunner scripfile</span><br><span class="line"></span><br><span class="line">C:\Users\admin&gt;monkeyrunner E:\monkeyrunner_script\kyb.py</span><br></pre></td></tr></table></figure>

<h3 id="3-MonkeyImage类"><a href="#3-MonkeyImage类" class="headerlink" title="3.MonkeyImage类"></a><em><strong>3.MonkeyImage类</strong></em></h3><p>MonkeyImage类在测试过程中用来保存各种格式的测试截图，并可以进行图像对比。</p>
<p><img src="https://pic.imgdb.cn/item/61373df744eaada739c9c171.jpg"></p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><p>· takeSnapshot() 进行屏幕截图</p>
<p>· writeToFile() 保存图像文件到指定的文件路径</p>
<h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a><strong>用法示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from com.android.monkeyrunner import MonkeyImage as mi  </span><br><span class="line">print(&quot;takeSnapshot&quot;)</span><br><span class="line">screenshot=device.takeSnapshot()  </span><br><span class="line">screenshot.writeToFile(r&#x27;E:\monkeyrunner_script\test.png&#x27;,&#x27;png&#x27;)  </span><br></pre></td></tr></table></figure>

<h2 id="综合实践"><a href="#综合实践" class="headerlink" title="综合实践"></a><em><strong>综合实践</strong></em></h2><h4 id="测试场景-1"><a href="#测试场景-1" class="headerlink" title="测试场景"></a><strong>测试场景</strong></h4><p>· 连接设备，自动安装并启动考研帮app</p>
<p>· 启动后登录账号，然后截图并保存到指定文件位置。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h4><p>· 连接设备</p>
<p>· 安装app</p>
<p>· 启动app</p>
<p>· 输入用户名密码点击登录按钮</p>
<p>· 截图</p>
<h4 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a><strong>脚本实现</strong></h4><p>kyb_login.py</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from com.android.monkeyrunner import MonkeyRunner as mr</span><br><span class="line">from com.android.monkeyrunner import MonkeyDevice as md</span><br><span class="line">from com.android.monkeyrunner import MonkeyImage as mi</span><br><span class="line"></span><br><span class="line">print(&quot;connect devices...&quot;)</span><br><span class="line"></span><br><span class="line">device=mr.waitForConnection()</span><br><span class="line"></span><br><span class="line">print(&quot; install app&quot;)</span><br><span class="line">device.installPackage(r&#x27;C:\Users\admin\Desktop\kaoyan3.1.0.apk&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;launch app...&quot;)</span><br><span class="line">package=&#x27;com.tal.kaoyan&#x27;</span><br><span class="line">activity=&#x27;com.tal.kaoyan.ui.activity.SplashActivity&#x27;</span><br><span class="line">runComponent=package+&#x27;/&#x27;+activity</span><br><span class="line"></span><br><span class="line">device.startActivity(component=runComponent)</span><br><span class="line">mr.sleep(3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;touch cancel button&quot;)</span><br><span class="line">device.touch(618,895,&#x27;DOWN_AND_UP&#x27;)</span><br><span class="line">mr.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;touch skip button&quot;)</span><br><span class="line">device.touch(804,67,&#x27;DOWN_AND_UP&#x27;)</span><br><span class="line">mr.sleep(1)</span><br><span class="line"></span><br><span class="line">print(&quot;input username and password&quot;)</span><br><span class="line">device.touch(57,373,&#x27;DOWN_AND_UP&#x27;)</span><br><span class="line">mr.sleep(2)</span><br><span class="line">device.type(账户)</span><br><span class="line"></span><br><span class="line">device.touch(152,480,&#x27;DOWN_AND_UP&#x27;)</span><br><span class="line">mr.sleep(2)</span><br><span class="line">device.type(密码)</span><br><span class="line">mr.sleep(2)</span><br><span class="line"></span><br><span class="line">print(&quot;touch login button&quot;)</span><br><span class="line">device.touch(331,634,&#x27;DOWN_AND_UP&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;takeSnapshot&quot;)</span><br><span class="line">screenshot=device.takeSnapshot()</span><br><span class="line">screenshot.writeToFile(r&#x27;D:\monkeyrunner\kyb.png&#x27;,&#x27;png&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><em><strong>注意事项</strong></em></h3><p>方法调用错误</p>
<p><code>AttributeError: type object &#39;com.android.monkeyrunner.XXXXX&#39; has no attribute XXXXXX</code></p>
<p>检查调用的方法名是否写错，特别是注意区分大小写。</p>
<p>字符编码错误</p>
<p><code>SyntaxError: Non-ASCII character in file &#39;E:\monkeyrunner_script\kyb.py&#39;, but no encoding declared;</code></p>
<p>需要在代码顶部补充 # -<strong>- coding: utf-8 -</strong>- 或者去掉代码中的中文字符</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95/" data-id="ckt17z8lg0000zgty0nqrbuga" data-title="移动端测试概述" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-黑盒测试方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T10:03:40.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/">黑盒测试方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-等价类划分法"><a href="#1-等价类划分法" class="headerlink" title="1.等价类划分法"></a>1.等价类划分法</h1><h2 id="1-什么是等价类"><a href="#1-什么是等价类" class="headerlink" title="1. 什么是等价类"></a>1. <strong>什么是等价类</strong></h2><p>是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例。该方法是一种重要的,常用的黑盒测试用例设计方法。</p>
<h2 id="2-划分等价类"><a href="#2-划分等价类" class="headerlink" title="2. 划分等价类"></a>2. <strong>划分等价类</strong></h2><p>等价类是指某个输入域的子集合。在该子集合中,各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其它值的测试，因此,<strong>可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果。</strong></p>
<p>等价类划分可有两种不同的情况：有效等价类和无效等价类。</p>
<h3 id="1-有效等价类"><a href="#1-有效等价类" class="headerlink" title="1) 有效等价类"></a>1) <strong>有效等价类</strong></h3><p>是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。</p>
<h3 id="2-无效等价类"><a href="#2-无效等价类" class="headerlink" title="2) 无效等价类"></a>2) <strong>无效等价类</strong></h3><p>与有效等价类的定义恰巧相反。无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。</p>
<p>设计测试用例时,要同时考虑这两种等价类。因为软件不仅要能接收合理的数据,也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。</p>
<h2 id="3-划分等价类的方法"><a href="#3-划分等价类的方法" class="headerlink" title="3. 划分等价类的方法"></a>3. <strong>划分等价类的方法</strong></h2><p>1．在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类。</p>
<p>2．在输入条件规定了输入值的集合或者规定了”必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类；</p>
<p>3．在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类。</p>
<p>4．在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类。例：输入条件说明学历可为:专科、本科、硕士、博士四种之一，则分别取这四种这四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。</p>
<p>5．在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；</p>
<p>6．在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。</p>
<h2 id="4-设计测试用例"><a href="#4-设计测试用例" class="headerlink" title="4. 设计测试用例"></a>4. <strong>设计测试用例</strong></h2><p>在确立了等价类后,可建立等价类表,列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：</p>
<p>  为每一个等价类规定一个唯一的编号；</p>
<p>  设计一个新的测试用例,使其尽可能多地覆盖尚未被覆盖地有效等价类,重复这一步，直到所有的有效等价类都被覆盖为止；</p>
<p>  设计一个新的测试用例,使其仅覆盖一个尚未被覆盖的无效等价类,重复这一步，直到所有的无效等价类都被覆盖为止。</p>
<h2 id="5-三角形案例"><a href="#5-三角形案例" class="headerlink" title="5. 三角形案例"></a>5. <strong>三角形案例</strong></h2><p>题目：某程序规定：”输入三个整数 a 、 b 、 c 分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型，当此三角形为一般三角形、等腰三角形及等边三角形时，分别作计算 … “。用等价类划分方法为该程序进行测试用例设计。</p>
<p>分析题目中给出和隐含的对输入条件的要求：</p>
<p>（1）整数 （2）三个数 （3）非零数 （4）正数</p>
<p>（5）两边之和大于第三边 （6）等腰 （7）等边</p>
<p>如果 a 、 b 、 c 满足条件（ 1 ） ~ （ 4 ），则输出下列四种情况之一：</p>
<p>如果不满足条件（5），则程序输出为 “ 非三角形 “ 。</p>
<p>如果三条边相等即满足条件（7），则程序输出为 “ 等边三角形 “ 。</p>
<p>如果只有两条边相等、即满足条件（6），则程序输出为 “ 等腰三角形 “ 。</p>
<p>如果三条边都不相等，则程序输出为 “ 一般三角形 “ 。</p>
<h1 id="2-边界值分析法"><a href="#2-边界值分析法" class="headerlink" title="2.边界值分析法"></a>2.<strong>边界值分析法</strong></h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h2><p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。</p>
<h2 id="2-与等价类的区别"><a href="#2-与等价类的区别" class="headerlink" title="2. 与等价类的区别"></a>2. <strong>与等价类的区别</strong></h2><p>边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。</p>
<p>边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。</p>
<h2 id="3-边界值分析法的考虑"><a href="#3-边界值分析法的考虑" class="headerlink" title="3. 边界值分析法的考虑"></a>3. <strong>边界值分析法的考虑</strong></h2><p>长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。</p>
<p>使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。</p>
<h2 id="4-常见的边界值"><a href="#4-常见的边界值" class="headerlink" title="4. 常见的边界值"></a>4. <strong>常见的边界值</strong></h2><p>A. 屏幕上光标在最左上、最右下位置</p>
<p>B. 报表的第一行和最后一行</p>
<p>C. 数组元素的第一个和最后一个</p>
<p>D. 循环的第 0 次、第 1 次和倒数第 2 次、最后一次</p>
<h2 id="5-边界值分析"><a href="#5-边界值分析" class="headerlink" title="5. 边界值分析"></a>5. <strong>边界值分析</strong></h2><p><strong>A. 边界值分析使用与等价类划分法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。</strong></p>
<p>例：测试计算平方根的函数</p>
<p>–输入：实数</p>
<p>–输出：实数</p>
<p>–规格说明：当输入一个0或比0大的数的时候，返回其正平方根；当输入一个小于0的数时，显示错误信息”平方根非法-输入值小于0”并返回0；</p>
<p><strong>B. 等价类划分：</strong><br>        可以考虑作出如下划分：<br>            a、输入 (i)&lt;0 和 (ii)&gt;=0<br>            b、输出 (a)&gt;=0 和 (b)为 Error<br>        测试用例有两个：<br>            a、输入4，输出2。对应于 (ii) 和 (a) 。<br>            b、输入-10，输出0和错误提示。对应于 (i) 和 (b) 。</p>
<p><strong>C. 边界值分析</strong></p>
<p>划分(ii)的边界为0和最大正实数；</p>
<p>划分(i)的边界为最小负实数和0。由此得到以下测试用例：<br>a、输入 {最小负实数}<br>b、输入 {绝对值很小的负数}<br>c、输入 0<br>d、输入 {绝对值很小的正数}<br>e、输入 {最大正实数}</p>
<p><strong>D. 通常情况下，软件测试所包含的边界检验有几种类型：数字、字符、位置、重量、大小、速度、方位、尺寸、空间等。</strong></p>
<p><strong>E. 相应地，以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、 最短/最长、 空/满等情况下。</strong></p>
<p><strong>F. 利用边界值作为测试数据</strong></p>
<h2 id="6-基于边界值分析方法选择测试用例的原则"><a href="#6-基于边界值分析方法选择测试用例的原则" class="headerlink" title="6. 基于边界值分析方法选择测试用例的原则"></a>6. <strong>基于边界值分析方法选择测试用例的原则</strong></h2><p>A. 如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。例如，如果程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取10及50，还应取10.01,49.99,9.99及50.01等。</p>
<p>B. 如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一,比最大个数多一的数作为测试数据。比如，一个输入文件应包括1~255个记录，则测试用例可取1和255，还应取0及256等。</p>
<p>C. 将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。例如，某程序的规格说明要求计算出”每月保险金扣除额为0至1165.25元”，其测试用例可取0.00及1165.24、还可取一0.01及1165．26等。</p>
<p>D. 再如一程序属于情报检索系统，要求每次”最少显示1条、最多显示4条情报摘要”，这时我们应考虑的测试用例包括1和4，还应包括0和5等。</p>
<p>E. 如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例。</p>
<p>F. 如果程序中使用了一个内部数据结构,则应当选择这个内部数据结构的边界上的值作为测试用例。</p>
<p>G. 分析规格说明,找出其它可能的边界条件。</p>
<h1 id="3-错误推断法"><a href="#3-错误推断法" class="headerlink" title="3.错误推断法"></a>3.<strong>错误推断法</strong></h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h2><p>基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。</p>
<h2 id="2-错误推测方法的基本思想"><a href="#2-错误推测方法的基本思想" class="headerlink" title="2. 错误推测方法的基本思想"></a>2. <strong>错误推测方法的基本思想</strong></h2><p>列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。</p>
<p>  例如, 输入数据和输出数据为0的情况；输入表格为空格或输入表格只有一行。 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。</p>
<p>  例如，前面例子中成绩报告的程序，采用错误推测法还可补充设计一些测试用例：</p>
<p>  I. 程序是否把空格作为回答</p>
<p>  II. 在回答记录中混有标准答案记录</p>
<p>  III. 除了标题记录外，还有一些的记录最后一个字符即不是2也不是3</p>
<p>  IV. 有两个学生的学号相同</p>
<p>V. 试题数是负数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/" data-id="ckszwww8c0000x8tybhzgbnzc" data-title="黑盒测试方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-缺陷的处理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/%E7%BC%BA%E9%99%B7%E7%9A%84%E5%A4%84%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T09:44:48.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/%E7%BC%BA%E9%99%B7%E7%9A%84%E5%A4%84%E7%90%86/">缺陷的处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-缺陷的基本理论"><a href="#1-缺陷的基本理论" class="headerlink" title="1.缺陷的基本理论"></a>1.缺陷的基本理论</h1><h2 id="1-什么是缺陷"><a href="#1-什么是缺陷" class="headerlink" title="1. 什么是缺陷"></a>1. <strong>什么是缺陷</strong></h2><p>软件存在着不符合质量需求或违背软件用户、客户、企业意愿的问题，这就是软件缺陷 （Defect），又叫“Bug（臭虫）”。</p>
<h2 id="2-缺陷的判断标准"><a href="#2-缺陷的判断标准" class="headerlink" title="2. 缺陷的判断标准"></a>2. <strong>缺陷的判断标准</strong></h2><p><strong>软件未达到产品说明书标明的功能；</strong></p>
<p>产品说明书简称为说明（spec）或产品说明（product spec），是软件开发小组 的一个协定。它对开发的产品进行定义，给出产品的细节、如何做、做什么、 不能做什么。这种协定从简单的口头说明到正式的书面文档有多种形式。 </p>
<p><strong>软件出现了产品说明书指明不会出现的错误；</strong> </p>
<p>如金融软件 7*24 工作不能宕机  </p>
<p><strong>软件功能超出产品说明书指明范围；</strong> </p>
<p><strong>软件未达到产品说明书虽未指出但应达到的目标；</strong> </p>
<p>如软件在断电时的意外处理 </p>
<p><strong>软件测试员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好。</strong></p>
<p>主要体现在易用性方面</p>
<h2 id="3-缺陷的表现形式"><a href="#3-缺陷的表现形式" class="headerlink" title="3. 缺陷的表现形式"></a>3. <strong>缺陷的表现形式</strong></h2><p>A. 用户要求的功能、特性没有实现或部分实现。 </p>
<p>B. 运行出错，包括运行中断、系统崩溃、界面混乱等。 </p>
<p>C. 数据结果不正确、精度不够、不完整或格式不统一。 </p>
<p>D. 文字显示内容不正确或拼写错误。 </p>
<p>E. 系统性能低下、系统资源浪费。</p>
<h2 id="4-缺陷的注意点"><a href="#4-缺陷的注意点" class="headerlink" title="4. 缺陷的注意点"></a>4. <strong>缺陷的注意点</strong></h2><h3 id="a-无效的缺陷"><a href="#a-无效的缺陷" class="headerlink" title="a. 无效的缺陷"></a>a. <strong>无效的缺陷</strong></h3><p>特点：指测试人员提交的不是缺陷的缺陷；怎么办：正确理解需求； 做好复现。</p>
<h3 id="b-重复的缺陷"><a href="#b-重复的缺陷" class="headerlink" title="b. 重复的缺陷"></a>b. <strong>重复的缺陷</strong></h3><p><strong>特点</strong>：同一个缺陷 A 测试工程师提交后，B 测试工程师又提交，或者自己提交的缺陷，与之前提交的缺陷相同或类似；</p>
<p> <strong>怎么办</strong> 尽量避免两个人同时测试同一模块； 自己提交的缺陷与自己的重复，提交前查找一下，增强开发知识。</p>
<h3 id="c-有争议的缺陷"><a href="#c-有争议的缺陷" class="headerlink" title="c. 有争议的缺陷"></a>c. <strong>有争议的缺陷</strong></h3><p>跟有关人员进行沟通、讨论 或者 搁置。</p>
<h3 id="d-无法再现的缺陷"><a href="#d-无法再现的缺陷" class="headerlink" title="d. 无法再现的缺陷"></a>d. <strong>无法再现的缺陷</strong></h3><p>首先，对这样的缺陷进行详细的记录，使用不同办法去尝试复现。其次，要合理地安排时间，要考虑到测试项目的整体进度，对一时难以再现的缺陷 。 可以暂时搁置，以保证项目的正常进度，并尽快提交给开发人员。 最后，在测试过程中对未再现缺陷予以关注。</p>
<h1 id="2-缺陷报告"><a href="#2-缺陷报告" class="headerlink" title="2.缺陷报告"></a>2.缺陷报告</h1><h2 id="1-缺陷报告的组成"><a href="#1-缺陷报告的组成" class="headerlink" title="1. 缺陷报告的组成"></a>1. <strong>缺陷报告的组成</strong></h2><ul>
<li>缺陷的标题/缺陷摘要/缺陷概述/缺陷基本信息 </li>
<li>预处理 </li>
<li>复现步骤 </li>
<li>期望结果 </li>
<li>实际结果 </li>
<li>缺陷的严重程度 </li>
<li>缺陷的优先级 </li>
<li>测试的软件和硬件环境 </li>
<li>测试的软件版本 </li>
<li>缺陷的类型 </li>
</ul>
<h2 id="2-怎么提交高质量的缺陷报告？"><a href="#2-怎么提交高质量的缺陷报告？" class="headerlink" title="2. 怎么提交高质量的缺陷报告？"></a>2. <strong>怎么提交高质量的缺陷报告？</strong></h2><ol>
<li><p>尽早提交缺陷报告。 </p>
</li>
<li><p>清楚地说明此问题对用户价值的危害。 </p>
</li>
<li><p>提供尽可能多的技术信息（如包含复现该缺陷需要的环境变量或测试所用的数据文 件），方便程序员调试。 </p>
</li>
<li><p>报告的软件缺陷进行了必要的隔离，报告的缺陷信息具体、准确。 </p>
</li>
<li><p>易于搜索软件测试报告的缺陷。 </p>
</li>
<li><p>一个缺陷报告中只报告了一种缺陷。 </p>
</li>
<li><p>缺陷报告中不要提问题。 </p>
</li>
<li><p>避免常见的错误 </p>
</li>
</ol>
<p>a. 我（I）、你（You）、他/她（He/She） </p>
<p>b. 情绪化的语言和强调符号！！！</p>
<p>c. 似乎（Seems）、看上去可能（Appears to be） </p>
<p>d. 认为比较幽默的内容 </p>
<p>e. 不确定的测试问题（Issues）</p>
<h1 id="3-缺陷的分类"><a href="#3-缺陷的分类" class="headerlink" title="3.缺陷的分类"></a>3.缺陷的分类</h1><h2 id="1-根据缺陷类型分类"><a href="#1-根据缺陷类型分类" class="headerlink" title="1.根据缺陷类型分类"></a>1.根据缺陷类型分类</h2><ul>
<li> 功能缺陷 </li>
<li> 界面缺陷 </li>
<li>文档缺陷 </li>
<li>代码缺陷 </li>
<li>算法错误 </li>
<li>性能缺陷</li>
</ul>
<h2 id="2-根据缺陷的等级分类"><a href="#2-根据缺陷的等级分类" class="headerlink" title="2. 根据缺陷的等级分类"></a>2. <strong>根据缺陷的等级分类</strong></h2><h3 id="A类—致命缺陷，包括以下各种错误："><a href="#A类—致命缺陷，包括以下各种错误：" class="headerlink" title="A类—致命缺陷，包括以下各种错误："></a>A类—致命缺陷，包括以下各种错误：</h3><ul>
<li><p>由于程序所引起的死机，非法退出； </p>
</li>
<li><p>死循环； </p>
</li>
<li><p>数据库发生死锁； </p>
</li>
<li><p>因错误操作导致的程序中断； </p>
</li>
<li><p>功能错误； </p>
</li>
<li><p>与数据库连接错误； </p>
</li>
<li><p>数据通讯错误</p>
<h3 id="B-类—严重缺陷，包括以下各种错误："><a href="#B-类—严重缺陷，包括以下各种错误：" class="headerlink" title="B 类—严重缺陷，包括以下各种错误："></a>B 类—严重缺陷，包括以下各种错误：</h3></li>
<li><p>程序错误； </p>
</li>
<li><p>程序接口错误； </p>
</li>
<li><p>数据库的表、业务规则、缺省值未加完整性等约束条件</p>
</li>
</ul>
<h3 id="C-类一般缺陷，包括以下各种错误："><a href="#C-类一般缺陷，包括以下各种错误：" class="headerlink" title="C 类一般缺陷，包括以下各种错误："></a>C 类一般缺陷，包括以下各种错误：</h3><ul>
<li>操作界面错误（包括数据窗口内列名定义、含义是否一致）； </li>
<li>打印内容、格式错误； </li>
<li>简单的输入限制未放在前台进行控制； </li>
<li>删除操作未给出提示； </li>
<li>数据库表中有过多的空字段</li>
</ul>
<h3 id="D类—较小缺陷，包括以下各种错误："><a href="#D类—较小缺陷，包括以下各种错误：" class="headerlink" title="D类—较小缺陷，包括以下各种错误："></a>D类—较小缺陷，包括以下各种错误：</h3><ul>
<li>界面不规范； </li>
<li>辅助说明描述不清楚； </li>
<li>输入输出不规范； </li>
<li>长操作未给用户提示； </li>
<li>提示窗口文字未采用行业术语； </li>
<li>可输入区域和只读区域没有明显的区分标志</li>
</ul>
<h2 id="4-缺陷报告的处理"><a href="#4-缺陷报告的处理" class="headerlink" title="4.缺陷报告的处理"></a>4.缺陷报告的处理</h2><ul>
<li>软件测试人员提交缺陷报告； </li>
<li>测试负责人审核后将缺陷报告分配给相关的开发人员修改； </li>
<li>缺陷被修改后由测试人员根据缺陷报告中的修改记录进行返测； </li>
<li>返测通过的缺陷报告由负责人关闭，返测未通过的缺陷报告直接返回开发人员重新修改，缺陷报告直到缺陷被修复以后才关闭； </li>
<li>关闭或已解决的缺陷报告可能会被阶段性的复审重新打开，这些报告一旦被再次打开应该立即处理。</li>
</ul>
<h1 id="4-常用的缺陷管理工具"><a href="#4-常用的缺陷管理工具" class="headerlink" title="4.常用的缺陷管理工具"></a>4.常用的缺陷管理工具</h1><p>Bugzilla </p>
<p>Mantis </p>
<p>Jira </p>
<p>ZenTao（禅道）</p>
<h1 id="5-测试报告"><a href="#5-测试报告" class="headerlink" title="5.测试报告"></a>5.测试报告</h1><p> <strong>测试报告一般包含哪些内容？</strong></p>
<p><strong>测试报告的版本、测试的人员和时间、测试所覆盖的缺陷</strong>——测试组在这轮测试中所有处理的缺陷，报告了测试组长处理的缺陷和实施工程师验证的缺陷。不仅要写出覆盖缺陷的总数，还要写明这些缺陷的去向。<strong>测试新发现的缺陷数量、上一版本活动缺陷的数量</strong>，经过此轮测试，所有活动缺陷的数量及其状态分类</p>
<p><strong>测试评估</strong>——写明在这一版本中，那些功能被实现了，那些还没有实现，这里只需写明和上一版本不同之处即可 </p>
<p><strong>急待解决的问题</strong>—写明当前项目组中面临的最优先的问题，可以重复提出 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/%E7%BC%BA%E9%99%B7%E7%9A%84%E5%A4%84%E7%90%86/" data-id="ckszwiqcm0000mkty3f9aae1g" data-title="缺陷的处理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-软件测试流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T09:21:18.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/">软件测试流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-测试需求"><a href="#1-测试需求" class="headerlink" title="1.测试需求"></a>1.测试需求</h1><h2 id="1-为什么要做测试需求"><a href="#1-为什么要做测试需求" class="headerlink" title="1. 为什么要做测试需求"></a>1. <strong>为什么要做测试需求</strong></h2><p>A. 软件测试需求是开发测试用例的依据；</p>
<p>B. 有助于保证测试的质量与进度；</p>
<p>C. 测试需求是衡量测试覆盖率的重要指标；</p>
<h2 id="2-不做需求分析的后果"><a href="#2-不做需求分析的后果" class="headerlink" title="2. 不做需求分析的后果"></a>2. <strong>不做需求分析的后果</strong></h2><p>A. 浪费时间和资源实现了用户不需要的需求；</p>
<p>B. 遗漏了需求文档中没提到，但很重要的需求，导致客户满意度降低。</p>
<p>C. 需求分析不到位，错误的估计了测试的工作量，导致延误发布周期，可能会降低发布质量。</p>
<h2 id="3-需求阶段主要做什么？"><a href="#3-需求阶段主要做什么？" class="headerlink" title="3. 需求阶段主要做什么？"></a>3. <strong>需求阶段主要做什么？</strong></h2><p>检查需求文档描述的正确性，整理出需求的疑问点，明确点，让所有人一致理解正确的需求。</p>
<h1 id="2-常见的功能测试点思路总结"><a href="#2-常见的功能测试点思路总结" class="headerlink" title="2.常见的功能测试点思路总结"></a>2.常见的功能测试点思路总结</h1><p>在做针对软件的功能做测试的时候，有一些操作可能是我们经常遇到的，要把软件测试工作做好，提高我们测试的效率。</p>
<p>首先就是要找出软件中的常用功能测试点，把共性的工作抽取后，个性的工作再逐个突破，工作会变得轻松起来。</p>
<p>这里我们把一些功能测试的点划分为三类：<strong>常见的操作、常见的控件、界面测试</strong>。</p>
<h2 id="1-常见的操作"><a href="#1-常见的操作" class="headerlink" title="1. 常见的操作"></a>1. <strong>常见的操作</strong></h2><p>在操作软件的时候，比如登录、添加、删除、查询等操作场景，是我们经常遇到的，下面我们逐个去分析遇到这类操作的时候，我们该如何去找测试点。</p>
<h3 id="登录：测试思路"><a href="#登录：测试思路" class="headerlink" title="登录：测试思路"></a><strong>登录：测试思路</strong></h3><ol>
<li>用户名和密码都符合要求(格式上的要求)</li>
<li>用户名和密码都不符合要求(格式上的要求)</li>
<li>用户名符合要求，密码不符合要求(格式上的要求)</li>
<li>密码符合要求，用户名不符合要求(格式上的要求)</li>
<li>用户名或密码为空</li>
<li>数据库中不存在的用户名，不存在的密码</li>
<li>数据库中存在的用户名，错误的密码</li>
<li>数据库中不存在的用户名，存在的密码</li>
<li>输入的数据前存在空格</li>
<li>输入正确的用户名密码以后按[enter]是否能登陆</li>
</ol>
<h3 id="添加：测试思路"><a href="#添加：测试思路" class="headerlink" title="添加：测试思路"></a><strong>添加：测试思路</strong></h3><ol>
<li>要添加的数据项均合理，检查数据库中是否添加了相应的数据　　</li>
<li>留出一个必填数据为空　　</li>
<li>按照边界值等价类设计测试用例的原则设计其他输入项的测试用例　　</li>
<li>不符合要求的地方要有错误提示　　</li>
<li>是否支持table键　　</li>
<li>按enter是否能保存　　</li>
<li>若提示不能保存，也要察看数据库里是否多了一条数据</li>
</ol>
<h3 id="删除：测试思路"><a href="#删除：测试思路" class="headerlink" title="删除：测试思路"></a><strong>删除：测试思路</strong></h3><ol>
<li>删除一个数据库中存在的数据，然后查看数据库中是否删除　　</li>
<li>删除一个数据库中并不存在的数据，看书否有错误提示，并且数据库中没有数据被删除。　　</li>
<li>输入一个格式错误的数据，看是否有错误提示，并且数据库中没有数据被删除。　　</li>
<li>输入的正确数据前加空格，看是否能正确删除数据　　</li>
<li>什么也不输入　　</li>
<li>是否指出table键　　</li>
<li>是否支持enter键</li>
</ol>
<h3 id="查询：测试思路"><a href="#查询：测试思路" class="headerlink" title="查询：测试思路"></a><strong>查询：测试思路</strong></h3><p><strong>精确查询：</strong></p>
<p>　　① 输入的查询条件为数据库中存在的数据，看是否能正确地查出相应得数据</p>
<p>　　② 输入正确的查询条件以前加上空格，看是否能正确地查出相应的数据</p>
<p>　　③ 输入格式或范围不符合要求的数据，看是否有错误提示</p>
<p>　　④ 输入数据库中不存在的数据</p>
<p>　　⑤ 不输入任何数据</p>
<p>　　⑥ 是否支持table键</p>
<p>　　⑦ 是否支持enter键</p>
<p><strong>模糊查询：</strong></p>
<p>　　在精确查询的基础上加上以下一点</p>
<p>　　① 输入一些字符，看是否能查出数据库中所有的相关信息</p>
<h3 id="查找替换：测试思路"><a href="#查找替换：测试思路" class="headerlink" title="查找替换：测试思路"></a><strong>查找替换：测试思路</strong></h3><p>案例:打开word中的”替换”对话框</p>
<p>测试本功能有通过测试和失败测试两种情况</p>
<p>通过测试:</p>
<p>　　1，输入内容直接查找，或查找全部</p>
<p>　　2，在组合框中寻找已经查找过的内容，再次查找并确认文档的内容正确，如，已经查找过”测试用例”，再次进入不用重新输入查找内容，直接在文档中搜寻就可以.</p>
<p>失败测试:</p>
<p>　　1，输入过长或过短的查询字符串.如，假设查询的字符串长度为1到255，那么输入0，1，2，256，255和254进行测试;</p>
<p>　　2，输入特殊字符集，如，在word中.^g代表图片，^代表分栏符，可以输入这类特殊字符测试;</p>
<p>替换测试大体相同.</p>
<h2 id="2-常见的控件"><a href="#2-常见的控件" class="headerlink" title="2.常见的控件"></a>2.常见的控件</h2><h3 id="文本框：测试思路"><a href="#文本框：测试思路" class="headerlink" title="文本框：测试思路"></a><strong>文本框：测试思路</strong></h3><p>​        a，输入正常的字母或数字。</p>
<p>　　b，输入已存在的文件的名称;</p>
<p>　　c，输入超长字符。例如在“名称”框中输入超过允许边界个数的字符，假设最多255个字符，尝试输入 256个字符，检查程序能否正确处理;</p>
<p>　　d，输入默认值，空白，空格;</p>
<p>　　e，若只允许输入字母，尝试输入数字;反之;尝试输入字母;</p>
<p>　　f，利用复制，粘贴等操作强制输入程序不允许的输入数据;</p>
<p>　　g，输入特殊字符集，例如，NULL及 等;</p>
<p>　　h，输入超过文本框长度的字符或文本，检查所输入的内容是否正常显示;</p>
<p>　　i，输入不符合格式的数据，检查程序是否正常校验，如，程序要求输入年月日格式为yy/mm/dd，实际输入yyyy/mm/dd，程序应该给出错误提示</p>
<h3 id="按钮：测试思路"><a href="#按钮：测试思路" class="headerlink" title="按钮：测试思路"></a><strong>按钮：测试思路</strong></h3><p>　    a，点击按钮正确响应操作。如，单击确定，正确执行操作;单击取消，退出窗口;</p>
<p>　　b，对非法的输入或操作给出足够的提示说明，如，输入月工作天数为32时，单击”确定“后系统应提示:天数不能大于31;</p>
<p>　　c，对可能造成数据无法恢复的操作必须给出确认信息，给用户放弃选择的机会;</p>
<p><strong>单选按钮控件的测试</strong></p>
<p>　　a，一组单选按钮不能同时选中，只能选中一个。</p>
<p>　　b，逐一执行每个单选按钮的功能。分别选择了“男”“女”后，保存到数据库的数据应该相应的分别为“男”“女”;</p>
<p>　　c，一组执行同一功能的单选按钮在初始状态时必须有一个被默认选中，不能同时为空;</p>
<h3 id="下拉列表框：测试思路"><a href="#下拉列表框：测试思路" class="headerlink" title="下拉列表框：测试思路"></a><strong>下拉列表框：测试思路</strong></h3><p>　     A：条目内容正确，根据需求说明书确定列表的各项内容正确，没有丢失或错误;</p>
<p>　　B：列表框的内容较多时要使用滚动条;</p>
<p>　　C：列表框允许多选时，要分别检查shift选中条目，按ctrl选中条目和直接用鼠标选中多项条目的情况;</p>
<h3 id="复选框：测试思路"><a href="#复选框：测试思路" class="headerlink" title="复选框：测试思路"></a><strong>复选框：测试思路</strong></h3><p>​        a，多个复选框可以被同时选中;</p>
<p>　　b，多个复选框可以被部分选中;</p>
<p>　　c，多个复选框可以都不被选中;</p>
<p>　　d，逐一执行每个复选框的功能;</p>
<h3 id="滚动条：测试思路"><a href="#滚动条：测试思路" class="headerlink" title="滚动条：测试思路"></a><strong>滚动条：测试思路</strong></h3><p>​        A.滚动条的长度根据显示信息的长度或宽度及时变换，这样有利于用户了解显示信息的位置和百分比，如，            word中浏览100页文档，浏览到50页时，滚动条位置应处于中间;</p>
<p>　　B。拖动滚动条，检查屏幕刷新情况，并查看是否有乱码;</p>
<p>　　C.单击滚动条;</p>
<p>　　D.用滚轮控制滚动条;</p>
<p>　　E.滚动条的上下按钮</p>
<h3 id="各种控件和窗体混合使用时的测试思路："><a href="#各种控件和窗体混合使用时的测试思路：" class="headerlink" title="各种控件和窗体混合使用时的测试思路："></a><strong>各种控件和窗体混合使用时的测试思路：</strong></h3><p>各种控件在窗体中混和使用时的测试</p>
<p>　　a，控件间的相互作用;</p>
<p>　　b，tab键的顺序，一般是从上到下，从左到右;</p>
<p>　　c，热键的使用，逐一测试;</p>
<p>　　d，enter键和esc键的使用;</p>
<p>　　在测试中，应遵循由简入繁的原则，先进行单个控件功能的测试，确保实现无误后，再进行多个控件的的功能组合的测试。</p>
<p>　　ps:密码输入框测试时要特别注意进行字母大写输入的测试。</p>
<h2 id="3-界面测试"><a href="#3-界面测试" class="headerlink" title="3.界面测试"></a>3.界面测试</h2><h3 id="测试窗体的思路"><a href="#测试窗体的思路" class="headerlink" title="测试窗体的思路:"></a><strong>测试窗体的思路:</strong></h3><p>　　a，窗体大小，大小要合适，控件布局合理;</p>
<p>　　b，移动窗体.快速或慢速移动窗体，背景及窗体本身刷新必须正确;</p>
<p>　　c，缩放窗体，窗体上的控件应随窗体的大小变化而变化;</p>
<p>　　d，显示分辨率.必须在不同的分辨率的情况下测试程序的显示是否正常;</p>
<p>　　进行测试时还要注意状态栏是否显示正确;工具栏的图标执行操作是否有效，是否与菜单懒中图标显示一致;错误信息内容是否正确，无错别字，且明确等等;</p>
<h3 id="控件测试思路"><a href="#控件测试思路" class="headerlink" title="控件测试思路:"></a><strong>控件测试思路:</strong></h3><p>a，窗体或控件的字体和大小要一致;</p>
<p>b，注意全角，半角混合</p>
<p>c，无中英文混合.</p>
<h3 id="菜单测试设计思路："><a href="#菜单测试设计思路：" class="headerlink" title="菜单测试设计思路："></a><strong>菜单测试设计思路：</strong></h3><p>​        a，选择菜单是否可以正常工作，并与实际执行内容一致;</p>
<p>　　b，是否有错别字:</p>
<p>　　c，快捷键是否重复;</p>
<p>　　d，热键是否重复;</p>
<p>　　e，快捷键与热键操作是否有效</p>
<p>　　f，是否存在中英文混合</p>
<p>　　g，菜单要与语境相关，如，不同权限的用户登陆一个应用程序，不同级别的用户可以看到不同级别的菜单并使用不同级别的功能;</p>
<h1 id="3-测试计划"><a href="#3-测试计划" class="headerlink" title="3.测试计划"></a>3.测试计划</h1><h2 id="测试计划包含的内容"><a href="#测试计划包含的内容" class="headerlink" title="测试计划包含的内容"></a>测试计划包含的内容</h2><ul>
<li> 测试项目简介</li>
<li> 需要测试的特征</li>
<li> 不需要测试的特征</li>
<li> 测试的方法 （测试人员、测试工具、测试流程）</li>
<li> 测试环境（软件、硬件、网络）</li>
<li> 测试开始条件和结束条件</li>
<li> 测试者的任务、培训</li>
<li> 测试进度与跟踪</li>
<li> 测试风险与解决</li>
<li> 本测试计划的审批与变更方式</li>
</ul>
<h1 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4.测试用例"></a>4.测试用例</h1><h2 id="1-什么是测试用例？"><a href="#1-什么是测试用例？" class="headerlink" title="1. 什么是测试用例？"></a>1. <strong>什么是测试用例？</strong></h2><p>测试用例是一组由前提条件、输入、执行条件、预期结果等组成，以完成对某个特定需求或者目标测试的数据，体现测试方案、方法、技术和策略的文档。</p>
<h2 id="2-测试用例的组成。"><a href="#2-测试用例的组成。" class="headerlink" title="2.测试用例的组成。"></a>2.<strong>测试用例的组成。</strong></h2><p>测试用例九个基本项是：</p>
<ul>
<li>用例编号</li>
<li>测试项目</li>
<li>用例名称</li>
<li>重要级别</li>
<li>前置条件</li>
<li>测试数据</li>
<li>操作步骤</li>
<li>预期结果</li>
<li>实际结果</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/" data-id="ckszvtnly0000oktyeczk63lg" data-title="软件测试流程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ftp工具的搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/ftp%E5%B7%A5%E5%85%B7%E7%9A%84%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T09:08:48.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/ftp%E5%B7%A5%E5%85%B7%E7%9A%84%E6%90%AD%E5%BB%BA/">ftp工具的搭建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们在工作中经常使用到ftp服务器。包括我们的server-u服务器，但是我们的server-u是收费软件，如果公司对软件版权问题比较注重的话，不建议使用server-u，特别是如果公司有安装了server2008的话，我们就可以使用server2008子代的IIS工具来搭建我们的ftp服务器。今天我们就来一步一步搭建我们的ftp服务器。</p>
<h1 id="1、环境要求。"><a href="#1、环境要求。" class="headerlink" title="1、环境要求。"></a>1、环境要求。</h1><p>安装有windows server 2008或者其他服务器版本的window操作系统的机器。</p>
<h1 id="2、创建用户组"><a href="#2、创建用户组" class="headerlink" title="2、创建用户组"></a>2、创建用户组</h1><p>server 2008对用户组和用户的管理比较严格，而且我们作为一个ftp服务器，肯定涉及到非常多的用户，单独使用用户来管理工作量非常大而且不显示，所以这里我们首先创建一个用户组ftpGroup。</p>
<p>a、点击开始-&gt;管理工具-&gt;服务器管理器</p>
<p>b、右键 新建组</p>
<h1 id="3、创建用户"><a href="#3、创建用户" class="headerlink" title="3、创建用户"></a>3、创建用户</h1><p>作为ftp服务器，需要多个用户，我们这里只创建一个其他的大家按照同样的方法创建即可。</p>
<p>a、用户 -&gt;新用户</p>
<p>b、输入用户名</p>
<p>输入用户密码（用户密码会被进行简单性校验，最好包含字母字符和数字）</p>
<p>去掉用户下次登录时必须更改密码选项</p>
<p>勾选密码永不过期，点击创建。</p>
<p>c、创建完成后会再次弹出窗口用于创建下个用户，这里我们不在创建，大家根据需求可以创建多个。</p>
<p>d、修改用户组</p>
<p>ftpuser1-&gt;右键-&gt;属性</p>
<p>e 、修改用户属组</p>
<p>切换到隶属于标签</p>
<p>点击添加，输入组名称后点击检查名称</p>
<p>点击之后会在名称之前加上本机的名称，这个大家跟我的会不一样，没有关系，确定。</p>
<p>删除其他属组</p>
<p>选择Users属组，点击删除，应用，确定。</p>
<h1 id="4、安装FTP服务器"><a href="#4、安装FTP服务器" class="headerlink" title="4、安装FTP服务器"></a>4、安装FTP服务器</h1><p>a、点击角色-&gt;添加角色</p>
<p>勾选web服务器IIS</p>
<p>勾选ftp服务器</p>
<h1 id="5、配置FTP服务器"><a href="#5、配置FTP服务器" class="headerlink" title="5、配置FTP服务器"></a>5、配置FTP服务器</h1><p>a、角色-&gt;web服务器-&gt;internet信息服务（IIS）管理器</p>
<p>在主机名称上右键-&gt;添加FTP站点</p>
<p>注意站点名称不要包含中文,其他没有要求。</p>
<p>物理路径选定本地文件夹。</p>
<p>没有SSL证书，直接选择无。</p>
<p>身份验证选择基本</p>
<p>授权选择指定角色或用户组</p>
<p>ftpGroup （这里使用我们第一步创建的ftp分组）</p>
<p>权限（读写权限）</p>
<h1 id="6、设置目录权限"><a href="#6、设置目录权限" class="headerlink" title="6、设置目录权限"></a>6、设置目录权限</h1><p>找到磁盘文件,右键-&gt;属性</p>
<p>切换到安全标签，点击编辑</p>
<p>点击添加-&gt;输入组名称ftpGroup-&gt;检查-&gt;确定</p>
<p>应用 -&gt;确定</p>
<h1 id="7、重启服务器（可选）"><a href="#7、重启服务器（可选）" class="headerlink" title="7、重启服务器（可选）"></a>7、重启服务器（可选）</h1><p>由于涉及用户组的变更，可能需要重启后才能生效。建议重启服务器后再测试连接。</p>
<p>否则可能导致无法连接ftp服务器。</p>
<h1 id="8、连接验证"><a href="#8、连接验证" class="headerlink" title="8、连接验证"></a>8、连接验证</h1><p>a、本机浏览器验证</p>
<p>网址：<a href="ftp://localhost/">ftp://localhost/</a></p>
<p>b、局域网浏览器访问</p>
<p>查看服务器ip地址为192.168.128.140</p>
<p>使用局域网内其他电脑访问<a href="ftp://192.168.128.140/">ftp://192.168.128.140</a></p>
<p>c、xftp访问</p>
<p>设置主机为192.168.128.140</p>
<p>设置协议为FTP</p>
<p>输入用户名和密码</p>
<p>切换到选项卡，设置编码为GBK （如果使用默认的Unicode上传会导致上传的中文名称文件乱码）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/ftp%E5%B7%A5%E5%85%B7%E7%9A%84%E6%90%AD%E5%BB%BA/" data-id="ckszuu68o0000n8ty7xfm7abq" data-title="ftp工具的搭建" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-appium环境搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/appium%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T08:27:28.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/appium%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">appium环境搭建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h1><ul>
<li>Node.js</li>
<li>Appium</li>
<li>Appium-desktop</li>
<li>Appium-doctor</li>
<li>Appium-Python-Client</li>
<li>Python</li>
<li>JDK</li>
<li>Andriod SDK</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h1><p>下载地址：<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a></p>
<p>输入如下命令：</p>
<p><code>C:\Users\admin&gt;node -v</code></p>
<p>14.17.5</p>
<p><code>C:\Users\admin&gt;npm -v</code></p>
<p>6.14.14</p>
<ul>
<li>npm（node package manage）是node.js安装包管理工具，类似Python中的pip工具。</li>
<li>如果显示‘npm’不是内部命令提示，则可以管理员省份运行cmd，如果还是失败，则需要检查一下环境变量是否配置，或者重新安装nodejs。</li>
</ul>
<h1 id="2-安装appium"><a href="#2-安装appium" class="headerlink" title="2.安装appium"></a>2.安装appium</h1><p><code>npm install -g appium</code></p>
<h4 id="appium配置"><a href="#appium配置" class="headerlink" title="appium配置"></a>appium配置</h4><p>安装完成之后可以使用如下命令查看appium的安装路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin&gt;where appium</span><br><span class="line"></span><br><span class="line">C:\Users\admin\AppData\Roaming\npm\appium</span><br><span class="line"></span><br><span class="line">C:\Users\admin\AppData\Roaming\npm\appium.cmd</span><br></pre></td></tr></table></figure>



<p>在控制台输入命令 appium即可启动appium服务，appium -v查看版本</p>
<p><code>C:\Users\admin&gt;appium -v</code></p>
<h1 id="3-安装appium-desktop"><a href="#3-安装appium-desktop" class="headerlink" title="3.安装appium-desktop"></a>3.安装appium-desktop</h1><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/appium/appium-desktop/releases">https://github.com/appium/appium-desktop/releases</a></p>
<h1 id="4-python环境安装配置"><a href="#4-python环境安装配置" class="headerlink" title="4.python环境安装配置"></a>4.python环境安装配置</h1><p>安装成功之后输入命令 python –version看到如下提示即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\C\:\\Users\\\admin\&gt;\python\ \--version\</span><br><span class="line"></span><br><span class="line">\Python\ 3.6.6</span><br></pre></td></tr></table></figure>



<h1 id="5-jdk环境配置"><a href="#5-jdk环境配置" class="headerlink" title="5.jdk环境配置"></a>5.jdk环境配置</h1><p>安装完成后配置环境变量JAVA_HOME,在PATH中添加java和javac的地址</p>
<p>查看版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\adm&gt;java -version</span><br><span class="line">java version &quot;1.8.0_66&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_66-b18)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.66-b18, mixed mode)</span><br><span class="line"></span><br><span class="line">C:\Users\adm&gt;javac -version</span><br><span class="line">javac 1.8.0_66</span><br></pre></td></tr></table></figure>



<h1 id="6-ANDROID-SDK安装"><a href="#6-ANDROID-SDK安装" class="headerlink" title="6.ANDROID SDK安装"></a>6.ANDROID SDK安装</h1><p>下载地址： <a target="_blank" rel="noopener" href="http://tools.android-studio.org/index.php/sdk">http://tools.android-studio.org/index.php/sdk</a></p>
<p>安装完成后需要配置环境变量：ANDROID_HOME</p>
<h1 id="7-安装appium-doctor"><a href="#7-安装appium-doctor" class="headerlink" title="7.安装appium-doctor"></a>7.安装appium-doctor</h1><p>appium-doctor可以检测Appium整体依赖环境配置情况。</p>
<p><code>C:\Users\\admin\\&gt;npm install\ appium-doctor -g</code></p>
<p>在cmd输入命令</p>
<p><code>appium-doctor</code></p>
<p>必要项全绿说明安装成功</p>
<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://testerhome.com/topics/13146">https://testerhome.com/topics/13146</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/appium%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" data-id="ckszugd1k00002otybwjgf1c4" data-title="appium环境搭建" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-测试理论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/30/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2021-08-30T08:58:08.000Z" itemprop="datePublished">2021-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/30/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/">测试理论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-软件研发流程"><a href="#1-软件研发流程" class="headerlink" title="1.软件研发流程"></a>1.软件研发流程</h1><h2 id="1-软件的开发模型"><a href="#1-软件的开发模型" class="headerlink" title="1. 软件的开发模型"></a>1. 软件的开发模型</h2><p>软件测试工作与软件开发模型息息相关，在不同的软件开发模型中，测试的任务和作用也不相同，因此测试人员要充分了解软件开发模型，以便找准自己在其中的定位与任务。</p>
<p>软件开发模型规定了软件开发应遵循的步骤，是软件开发的导航图，它能够清晰、直观地表达软件开发的全过程，以及每个阶段要进行的活动和要完成的任务。</p>
<p>开发人员在选择开发模型时，要根据软件的特点、开发人员的参与方式选择稳定可靠的开发模型自有软件开发以来，软件开发模型也从最初的“边做边改”发展出了多个模型，下面以软件开发模型发展历史为顺序，介绍几个典型的开发模型。</p>
<ol>
<li>瀑布模型</li>
</ol>
<p>在20世纪70年代，由温斯顿·罗伊斯（Winston Royce）提出，瀑布模型一直是惟一被广泛采用的软件过程模型，现在它仍然是软件工程中应用得非常广泛的过程模型。瀑布模型是一种线形的、顺序的软件开发模型，主要分为6个阶段:可行性计划研究→需求分析→软件设计→编码→测试→运行维护。 </p>
<p>图1-2所示瀑布模型</p>
<p>在瀑布模型中，软件开发的各项活动严格按照这条线进行，只有当一个阶段任务完成之后才能开始下一个阶段。软件开发的每一个阶段都要有结果产出，结果经过审核验证之后作为下一个阶段的输入，下个阶段才可以顺利进行。如果结果审核验证不通过，则需要返回修改。</p>
<p>瀑布模型为整个项目划分了清晰的检查点，当一个阶段完成之后，只需要把全部精力放置在后面的开发上即可，它有利于大型软件开发人员的组织管理及工具的使用与研究，可以提高开发的效率。</p>
<p>但是瀑布模型是严格按照线性方式进行的，无法适应用户需求变更，用户只能等到最后才能看到开发成果，增加了开发风险。如果开发人员与客户对需求理解有偏差，到最后开发完成后，最终成果与客户需求可能会差之千里。使用瀑布模型开发软件时，如果早期犯的错误在项目完成后才发现，此时再修改原来的错误需要付出巨大的代价。瀑布模型要求每一个阶段必须有结果产出，这就势必增加了文档的数量，使软件开发的工作量变大。</p>
<ol start="2">
<li>V模型</li>
</ol>
<p>V 模型最早是由Paul Rook 在20 世纪80 年代后期提出的，V 模型在英国国家计算中心文献中发布，目的是改进软件开发的效率和效果。它是软件测试最具代表性的测试模型之一。</p>
<p>在传统的开发模型中，如瀑布模型，通常把软件测试过程作为在需求分析、概要设计、详细设计和编码全部完成之后的一个阶段，尽管有时软件测试工作会占整个项目周期一半的时间，但是仍然被认为软件测试只是一个收尾工作，而不是主要的工程。故对以前的测试模型进行了一定程度的改进，V 模型其实是软件开发瀑布模型的变种，反映了软件测试活动与软件开发过程(从分析到设计)的关系。</p>
<p>V 模型从左到右，描述了基本的开发过程和测试行为，明确地标明了测试工程中存在的不同级别以及测试阶段和开发过程各阶段的对应关系。图中箭头代表了时间方向，左边下降的是开发过程各阶段，与此相对应的是右边上升的部分，即测试过程各阶段。</p>
<p>V 模型指出，单元和集成测试是验证程序设计，单元测试主要由白盒测试工程对代码进行测试，但目前国内真正做白盒测试的企业不多。这主要有两大原因：第一，白盒测试投入的成本很高，并且产出不明显，很多企业不希望投入更多的资源去做这项工作;第二，白盒测试对测试工程师的要求较高，在目前系统测试还没有完全成熟的情况下很难真正地开展白盒测试。而集成测试是介于白盒测试与系统测试之间的一种测试，也叫灰盒测试，由于它与白盒测试和系统测试之间没有明显的界限，所以在实际的测试过程中，即使开展集成测试也是由系统测试工程师来完成。</p>
<p>系统测试主要验证系统设计，检测系统功能、性能的质量特性是否达到系统设计的指标，由测试人员和用户进行软件的确认测试和验收测试，以及对需求说明书进行测试，以确定软件的实现是否满足用户需求或合同要求。</p>
<p>V 模型存在一定的局限性，它把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段。如果不做白盒测试，那么其实都是在系统完成集成后才开始系统测试的，这样需求分析阶段隐藏的问题一直到后期的验收测试才被发现，因此修改缺陷的成本就高了很多。</p>
<ol start="3">
<li>快速原型模型</li>
</ol>
<p>快速原型模型与瀑布模型正好相反，它在最初确定用户需求时快速构造岀一个可以运行的软件原型，这个软件原型向用户展示待开发软件的全部或部分功能和性能，客户对该原型进行审核评价，然后给出更具体的需求意见，这样逐步丰富细化需求，最后开发人员与客户达成最终共识，确定客户的真正需求。确定客户的真正需求之后，开始真正的软件开发。</p>
<p>快速原型模型类似于建造房子，确定客户对房子的需求之后快速地搭建一个房子模型，由客户对房子模型进行评价，房子的样式、功能、布局等是否满足需求，哪里需要改进等，最后确定了客户对房子的要求，就开始真正地建造房子。</p>
<p>与瀑布模型相比，快速原型模型克服了需求不明确带来的风险，适用于不能预先确定需求的软件项目。但快速原型模型关键在于快速构建软件原型，准确地设计出软件原型存在定的难度。此外，这种开发模型也不利于开发人员对产品进行扩展。</p>
<ol start="4">
<li>迭代模型</li>
</ol>
<p>迭代模型又称为增量模型或演化模型，它将一个完整的软件拆分成不同的组件，然后逐个组件地开发测试，每完成一个组件就展现给客户，让客户确认这一部件功能和性能是否达到客户需求，最终确定无误，将组件集成到软件体系结构中。</p>
<p>整个开发工作被组织为一系列短期、简单的小项目，称为一系列迭代，每一个迭代都需要经过需求分析→软件设计→编码→测试的过程。</p>
<p>在迭代模型中，第一个迭代(即第一个组件)往往是软件基本需求的核心部分，第一个组件完成之后，经过客户审核评价形成下一个组件的开发计划，包括对核心产品的修改和新功能的发布，这样重复迭代步骤直到实现最终完善的产品。</p>
<p>迭代模型可以很好地适应客户需求变更，它逐个组件地交付产品，客户可以经常看到产品，如果某个组件没有满足客户需求，则只需要更改这一个组件，降低了软件开发的成本与风险。但是选代模型需要将开发完成的组件集成到软件体系结构中，这样会有集成失败的风险，因此要求软件必须有开放式的体系结构。此外，迭代模型逐个组件地开发修改，很容易退化为“边做边改”的开发形式，从而失去对软件开发过程的整体控制。</p>
<ol start="5">
<li>螺旋模型</li>
</ol>
<p>螺旋模型由巴利·玻姆(Barry Boehm)于1988年提岀，该模型融合了瀑布模型、快速原型模型，它最大的特点是引入了其他模型所忽略的风险分析，如果项目不能排除重大风险，就停止项目从而减小损失。这种模型比较适合开发复杂的大型软件。</p>
<p>螺旋模型将整个项目开发过程划分为几个不同的阶段，每个阶段按部就班地执行，这种划分方式采用了瀑布模型。每个阶段在开始之前都要进行风险评估，如果能消除重大风险则可以开始该阶段任务。在每个阶段，首先构建软件原型，根据快速原型模型完成这个迭代过程，产出最终完善的产品，然后进入下一个阶段，同样下一个阶段开始之前也要进行风险评估，这样循环往复直到完成所有阶段的任务。螺旋模型的若干个阶段是沿着螺线方式进行的。</p>
<p>制订计划、风险分析、实施工程、客户评估，各象限含义如下。</p>
<p>(1)制订计划:确定软件目标，制订实施方案，并且列出项目开发的限制条件。</p>
<p>(2)风险分析:评价所制订的实施方案，识别风险并消除风险。</p>
<p>(3)实施工程:开发产品并进行验证</p>
<p>(4)客户评估:客户对产品进行审核评估，提出修正建议，制订下一步计划。</p>
<p>在螺旋模型中，每一个选代都需要经过这4个步骤，直到最后得到完善的产品，可以进行提交。</p>
<p>螺旋模型强调了风险分析，这意味着对可选方案和限制条件都进行了评估，更有助于将软件质量作为特殊目标融入产品开发之中。它以小分段构建大型软件，使成本计算变得简单容易，而且客户始终参与每个阶段的开发，保证了项目不偏离正确方向，也保证了项目的可控制性。</p>
<h2 id="2-软件开发生命周期"><a href="#2-软件开发生命周期" class="headerlink" title="2. 软件开发生命周期"></a>2. 软件开发生命周期</h2><p>软件和其他产品一样，都有一个从“出生”到“消亡”的过程，这个过程称为软件的生命周期。在软件的生命周期中，软件测试是非常重要的一个环节。</p>
<p>软件生命周期分为多个阶段，每个阶段有明确的任务，这样就使得结构复杂、管理复杂的软件开发变得容易控制和管理。通常，可将软件生命周期划分为6个阶段，每个阶段的目标任务及含义分别介绍如下。</p>
<p>第1阶段:问题定义，该阶段由软件开发方与需求方共同讨论，主要确定软件的开发目标及其可行性。</p>
<p>第2阶段:需求分析，该阶段对软件需求进行更深入的分析，划分出软件需要实现的功能模块，并制作成文档。需求分析在软件的整个生命周期中起着非常重要的作用，它直接关系到后期软件开发的成功率。在后期开发中，需求可能会发生变化，因此，在进行需求分析时，应考虑到需求的变化，以保证整个项目的顺利进行。</p>
<p>第3阶段:软件设计，该阶段在需求分析结果的基础上，对整个软件系统进行设计，如系统框架设计、数据库设计等。</p>
<p>第4阶段:软件开发，该阶段在软件设计的基础上，选择一种编程语言进行开发。在开发过程中，必须要制订统一的、符合标准的程序编写规范，以保证程序的可读性、易维护性以及可移植性。</p>
<p>第5阶段:软件测试，该阶段是软件开发完成后对软件进行测试，以查找软件设计与软件开发过程中存在的问题并加以修正。软件测试过程包括单元测试、集成测试、系统测试、验收测试等4个阶段;测试的方法以黑盒测试、白盒测试或者两者结合的形式进行。在测试过程中，为减少测试的随意性，需要制订详细的测试计划并严格遵守;测试完成之后，要对测试结果进行分析并对测试结果以文档的形式汇总。</p>
<p>第6阶段:软件维护，软件完成测试并投入使用之后，面对庞大的用户群体，软件可能无法满足用户使用需求，此时就需要对软件进行维护升级以延续软件的使用寿命。软件的维护包括纠错性维护和改进性维护两个方面。软件维护是软件生命周期中持续时间最长的阶段。</p>
<h2 id="3-项目团队里面的成员及其职责"><a href="#3-项目团队里面的成员及其职责" class="headerlink" title="3. 项目团队里面的成员及其职责"></a>3. 项目团队里面的成员及其职责</h2><p>项目经理：驱动整个项目的运转，负责制定计划，安排人力，管理进度，协调团队，进行重大决策。</p>
<p>架构师 / 系统工程师：技术专家，经验丰富，负责整个系统的体系架构的设计以及关键模块的设计。</p>
<p>程序员 / 开发人员：设计、编写软件，并修复软件中的缺陷。</p>
<p>测试工程师：负责找出软件产品存在的问题并报告。</p>
<p>实施/运维工程师：负责软件系统安装部署、升级维护。</p>
<p>资料工程师：负责编写软件产品附带的文件和联机帮助文档</p>
<p>配置管理员：负责管理程序员写的代码和资料工程师写的文档资料，并组合成一个软件包。</p>
<p>QA：质量监管人员</p>
<h1 id="2-软件测试的基础理论"><a href="#2-软件测试的基础理论" class="headerlink" title="2.软件测试的基础理论"></a>2.软件测试的基础理论</h1><h2 id="1-软件测试的定义"><a href="#1-软件测试的定义" class="headerlink" title="1.软件测试的定义"></a>1.软件测试的定义</h2><p>软件测试是使用人工或者自动手段运行或测定某个系统的过程，检验系统是否满足规定的需求，并找出预期结果与实际结果的差异。</p>
<h2 id="2-测试的对象"><a href="#2-测试的对象" class="headerlink" title="2.测试的对象"></a>2.测试的对象</h2><p>根据软件的定义，软件包括程序、文档，所以软件测试并不仅仅是程序测试。软件测试贯穿于整个软件生命周期中。</p>
<h2 id="3-软件测试的目的"><a href="#3-软件测试的目的" class="headerlink" title="3.软件测试的目的"></a>3.软件测试的目的</h2><p>软件测试的目的大家都能随口说出，如查找程序中的错误、保证软件质量、检验软件是否符合客户需求等。这些都对，但它们只是笼统地对软件测试目的进行了概括，比较片面结合软件开发、软件测试与客户需求可以将软件测试的目的归结为以下几点。</p>
<ol>
<li><p>预防缺陷，减少产品的风险：对于软件开发来说，软件测试通过找到的问题缺陷帮助开发人员找到开发过程中存在的问题，包括软件开发的模式、工具、技术等方面存在的问题与不足，预防下次缺陷的产生。</p>
</li>
<li><p>发现被测对象与用户需求之间的差异（俗称找BUG）</p>
</li>
<li><p>通过测试活动发现并解决缺陷，增加人们对被测对象的质量信心；</p>
</li>
<li><p>通过测试活动，发现被测对象的质量信息，为决策者提供数据依据；</p>
</li>
</ol>
<h2 id="4-软件测试应遵循的原则"><a href="#4-软件测试应遵循的原则" class="headerlink" title="4.软件测试应遵循的原则"></a>4.软件测试应遵循的原则</h2><ol>
<li>测试应该基于客户的需求</li>
<li>测试要尽早进行</li>
<li>穷尽测试是不可能的</li>
<li>测试缺陷要符合“二八”定理</li>
<li>杀虫剂的悖论</li>
<li>没有缺陷的软件是不存在的</li>
</ol>
<h1 id="3-软件测试的分类"><a href="#3-软件测试的分类" class="headerlink" title="3.软件测试的分类"></a>3.软件测试的分类</h1><h2 id="1-按照测试阶段划分"><a href="#1-按照测试阶段划分" class="headerlink" title="1.按照测试阶段划分"></a>1.按照测试阶段划分</h2><p>①　单元测试</p>
<p>单元测试是软件开发的第一步测试，目的是为了验证软件单元是否符合软件需求与设计。单元测试大多是开发人员进行的自测。</p>
<p>②　冒烟测试</p>
<p>冒烟测试最初是从电路板测试得来的，当电路板做好以后，首先会加电测试，如果电路板没有冒烟再进行其他测试，否则就必须重新设计后再次测试。</p>
<p>后来这种测试理念被引入到软件测试中。在软件测试中，冒烟测试是指软件构建版本建立后，对系统的基本功能进行简单的测试，这种测试重点验证的是程序的主要功能，而不会对具体功能进行深入测试。</p>
<p>如果测试未通过，需要返回给开发人员进行修正;如果测试通过则再进行其他测试。因此，冒烟测试是对新构建版本软件进行的最基本测试。</p>
<p>③　集成测试</p>
<p>集成测试是冒烟测试之后进行的测试，它是将已经测试过的软件单元组合在一起测试它们之间的接口，用于验证软件是否满足设计需求。</p>
<p>④　系统测试</p>
<p>系统测试是将经过测试的软件在实际环境中运行，并与其他系统的成分(如数据库、硬件和操作人员等)组合在一起进行的测试。</p>
<p>⑤　验收测试</p>
<p>验收测试主要是对软件产品说明进行验证，逐行逐字地按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。</p>
<h2 id="2-按照测试技术分类"><a href="#2-按照测试技术分类" class="headerlink" title="2.按照测试技术分类"></a>2.按照测试技术分类</h2><p>①　黑盒测试</p>
<p>不需要关注被测对象的内部结构，仅从用户需求的角度去考虑，是否满足显性或者隐性的需求。</p>
<p>②　白盒测试</p>
<p>白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程。</p>
<h2 id="3-按照软件质量分类"><a href="#3-按照软件质量分类" class="headerlink" title="3.按照软件质量分类"></a>3.按照软件质量分类</h2><p>①　功能测试</p>
<p>功能测试就是测试软件的功能是否满足客户的需求，包括准确性、易用性、适合性、互操作性等。</p>
<p>②　性能测试</p>
<p>性能测试就是测试软件的性能是否满足客户的需求，性能测试包括负载测试、压力测试、兼容性测试、可移植性测试和健壮性测试。</p>
<h2 id="4-按照自动化程度分类"><a href="#4-按照自动化程度分类" class="headerlink" title="4.按照自动化程度分类"></a>4.按照自动化程度分类</h2><p>按照自动化程度可以将软件测试分为手工测试与自动化测试。</p>
<p>①　手工测试</p>
<p>手工测试是测试人员一条一条地执行代码完成测试工作。手工测试比较耗时费力，而且测试人员如果是在疲惫状态下，则很难保证测试的效果。</p>
<p>②　自动化测试</p>
<p>自动化测试是借助脚本、自动化测试工具等完成相应的测试工作，它也需要人工的参与，但是它可以将要执行的测试代码或流程写成脚本，执行脚本完成整个测试工作。</p>
<h2 id="5-按照测试类型分类"><a href="#5-按照测试类型分类" class="headerlink" title="5.按照测试类型分类"></a>5.按照测试类型分类</h2><p>软件测试类型有多种，包括界面类测试、功能测试、性能测试、安全性测试、文档测试等，其中功能测试与性能测试前面已经介绍，下面主要介绍其他几种测试。</p>
<p>①　界面类测试</p>
<p>界面类测试是验证软件界面是否符合客户需求，包括界面布局是否美观、按钮是否齐全等。</p>
<p>②　安全性测试</p>
<p>安全性测试是测试软件在没有授权的内部或外部用户的攻击或恶意破坏时如何进行处理，是否能保证软件与数据的安全。</p>
<p>③　文档测试</p>
<p>文档测试以需求分析、软件设计、用户手册、安装手册为主，主要验证文档说明与实际软件之间是否存在差异。</p>
<h2 id="6-其他分类"><a href="#6-其他分类" class="headerlink" title="6.其他分类"></a>6.其他分类</h2><p>还有一些软件测试无法具体归到哪一类，但在测试行业中也会经常进行这些测试，如α测试、β测试、回归测试等，具体介绍如下。</p>
<p>①　α测试</p>
<p>α测试是指对软件最初版本进行测试。软件最初版本一般不对外发布，在上线之前，由开发人员和测试人员或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题整个测试过程是可控的。</p>
<p>②　β测试</p>
<p>β测试是指对上线之后的软件版本进行测试，此时软件已上线发布，但发布的版本中可能会存在较轻微的Bug，由用户在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。</p>
<p>③　回归测试</p>
<p>当测试人员发现缺陷以后，会将缺陷提交给开发人员，开发人员对程序进行修改，修改之后，测试人员会对修改后的程序重新进行测试，确认原有的缺陷已经消除并且没有引入新的缺陷，这个重新测试的过程就叫作回归测试。回归测试是软件测试工作中非常重要的一部分，软件开发的各个阶段都会进行多次回归测试。</p>
<p>④　随机测试</p>
<p>随机测试是没有测试用例、检查列表、脚本或指令的测试，它主要是根据测试人员的经验对软件进行功能和性能抽查。随机测试是根据测试用例说明书执行测试用例的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</p>
<h1 id="4-软件测试流程"><a href="#4-软件测试流程" class="headerlink" title="4.软件测试流程"></a>4.软件测试流程</h1><ol>
<li>测试需求分析阶段：</li>
</ol>
<p>阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议;</p>
<ol start="2">
<li>测试计划阶段：</li>
</ol>
<p>根据自己的角色说明 如:测试经理主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围(来自需求文档)，进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。测试人员的话一般是领取分配的测试任务;</p>
<ol start="3">
<li>测试设计阶段：</li>
</ol>
<p>主要是编写测试用例，会参考需求文档(原型图)，概要设计，详细设计等文档，用例编写完成之后会进行评审;</p>
<ol start="4">
<li>测试执行阶段：</li>
</ol>
<p>搭建环境，执行冒烟测试(预测试)，然后进入正式测试，bug管理,根据公司情况进行日报,周报跟踪进度及风险控制;</p>
<ol start="5">
<li>测试评估阶段：</li>
</ol>
<p>出测试报告，确认是否可以上线。</p>
<h1 id="5-测试文档介绍"><a href="#5-测试文档介绍" class="headerlink" title="5.测试文档介绍"></a>5.测试文档介绍</h1><p>在软件研发过程当中，会产生很多的文档，下面罗列测试阶段所产生的文档，包含但不仅限于如下文档。</p>
<table>
<thead>
<tr>
<th>文档的名称</th>
<th>包括但不限于以下内容</th>
<th>文档编写目的</th>
</tr>
</thead>
<tbody><tr>
<td>测试计划</td>
<td>测试的范围、测试的准则、测试的手段、测试工具、停止的标准、硬/软件环境、测试规划、测试执行、工作量预估、资源安排、进度安排、风险管理等。</td>
<td>明确测试工作内容（范围）、测试工作的方法以及测试工作所需要的各种资源。</td>
</tr>
<tr>
<td>测试用例</td>
<td>用例编号、用例名称、测试背景、测试数据、操作步骤、预期结果、实际结果、优先级、重要级、编写人、执行人、备注等。</td>
<td>避免漏测、多测，能够对项目的需求做一个理解，可以作为测试人员工作量的一个考核。</td>
</tr>
<tr>
<td>缺陷报告</td>
<td>缺陷编号、缺陷描述、严重度、缺陷状态、发现人、发现时间、修复时间、所属版本、所属模块、修复的优先级、详细描述、下一步处理人等。</td>
<td>把软件存在的缺陷准确的描述出来，便于开发人员修正，反映了当前产品的质量状态，更是测试人员价值的体现。</td>
</tr>
<tr>
<td>测试报告</td>
<td>包括项目背景、需求分析、测试时间、测试环境、评审记录、测试范围、测试用例、功能实现清单、缺陷统计、测试统计(包含资源、执行、问题统计)、测试总结是否通过、测试的风险。</td>
<td>把测试的过程和结果写成文档，对发现的问题和缺陷进行分析，为纠正软件的存在的质量问题提供依据，同时为软件验收和交付打下基础。</td>
</tr>
<tr>
<td>测试日、周报</td>
<td>1.当前测试进度的关键性数据(用例执行进度、发现问题情况、待回归的问题)2.遇到哪些测试活动中不能解决的问题风险，需要什么样的帮助。3.下一阶段的工作计划是什么？</td>
<td>要求内容是每日/周测试活动的概述，和下一天/周测试活动的计划，要求反映出当前测试进度，成果及问题。</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/30/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/" data-id="cksygndmw0000boty9zoqhicf" data-title="测试理论" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python学习相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/30/python%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2021-08-30T06:47:34.000Z" itemprop="datePublished">2021-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/30/python%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/">python学习相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-python的下载与安装"><a href="#1-python的下载与安装" class="headerlink" title="1.python的下载与安装"></a>1.python的下载与安装</h1><p><a target="_blank" rel="noopener" href="https://www.python.org/downloads/release/python-384/">https://www.python.org/downloads/release/python-384/</a> </p>
<p>安装可以参考： </p>
<p><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/cb5d6105a32b5f005c2fe0ea.html">https://jingyan.baidu.com/article/cb5d6105a32b5f005c2fe0ea.html</a> </p>
<p>安装注意： </p>
<p>在第一步的时候，一定要勾选上： </p>
<p>Add python to PATH </p>
<p>其余都是下一步 </p>
<p>直接安装下载的安装包即可（建议安装在 C 盘根目录）</p>
<h1 id="2-如何验证python"><a href="#2-如何验证python" class="headerlink" title="2.如何验证python"></a>2.如何验证python</h1><p>\1. </p>
<p>进入 cmd 窗口 </p>
<p>\2. </p>
<p>输入 python </p>
<p>\3. </p>
<p>显示以下界面，表示 python 安装成功</p>
<h1 id="3-输出与输入"><a href="#3-输出与输入" class="headerlink" title="3.输出与输入"></a>3.输出与输入</h1><p><code>print(&quot;字符串&quot;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`变量名=<span class="built_in">input</span>()`</span><br><span class="line">`<span class="built_in">print</span>(变量名)`</span><br></pre></td></tr></table></figure>

<h1 id="4-python数据类型"><a href="#4-python数据类型" class="headerlink" title="4.python数据类型"></a>4.python数据类型</h1><h2 id="1-常见的数据类型"><a href="#1-常见的数据类型" class="headerlink" title="1.常见的数据类型"></a>1.常见的数据类型</h2><p>字符串——str</p>
<p>整数——int</p>
<p>浮点数——float</p>
<p>布尔——bool</p>
<h2 id="2-检测数据类型"><a href="#2-检测数据类型" class="headerlink" title="2.检测数据类型"></a>2.检测数据类型</h2><p>python使用type函数</p>
<p><code>type(变量名)</code></p>
<p>返回值为变量类型</p>
<h2 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h2><p>以下假设变量 a=10，变量 b=21：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加 - 两个对象相加</td>
<td>a + b 输出结果 31</td>
</tr>
<tr>
<td>-</td>
<td>减 - 得到负数或是一个数减去另一个数</td>
<td>a - b 输出结果 -11</td>
</tr>
<tr>
<td></td>
<td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td>a  b 输出结果 210</td>
</tr>
<tr>
<td>/</td>
<td>除 - x 除以 y</td>
<td>b / a 输出结果 2.1</td>
</tr>
<tr>
<td>%</td>
<td>取模 - 返回除法的余数</td>
<td>b % a 输出结果 1</td>
</tr>
<tr>
<td></td>
<td>幂 - 返回x的y次幂</td>
<td>ab 为10的21次方</td>
</tr>
<tr>
<td>//</td>
<td>取整除 - 向下取接近商的整数</td>
<td><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td>
</tr>
</tbody></table>
<h2 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>等于 - 比较对象是否相等</td>
<td>(a == b) 返回 False。</td>
</tr>
<tr>
<td>!=</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>(a != b) 返回 True。</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 - 返回x是否大于y</td>
<td>(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td>(a &lt; b) 返回 True。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 - 返回x是否大于等于y。</td>
<td>(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 - 返回x是否小于等于y。</td>
<td>(a &lt;= b) 返回 True。</td>
</tr>
</tbody></table>
<h2 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单的赋值运算符</td>
<td>c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>=</td>
<td>乘法赋值运算符</td>
<td>c = a 等效于 c = c  a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>=</td>
<td>幂赋值运算符</td>
<td>c = a 等效于 c = c  a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
<tr>
<td>:=</td>
<td>海象运算符，可在表达式内部为变量赋值。Python3.8 版本新增运算符。</td>
<td>在这个示例中，赋值表达式可以避免调用 len() 两次: <code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td>
</tr>
</tbody></table>
<h2 id="python位运算符"><a href="#python位运算符" class="headerlink" title="python位运算符"></a>python位运算符</h2><table>
<thead>
<tr>
<th>&amp;</th>
<th>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</th>
<th>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1</td>
<td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody></table>
<h2 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>逻辑表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>x and y</td>
<td>布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td>
<td>(a and b) 返回 20。</td>
</tr>
<tr>
<td>or</td>
<td>x or y</td>
<td>布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td>
<td>(a or b) 返回 10。</td>
</tr>
<tr>
<td>not</td>
<td>not x</td>
<td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td>not(a and b) 返回 False</td>
</tr>
</tbody></table>
<h2 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><p>  身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象</td>
<td>x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
<td>x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody></table>
<h1 id="5-python容器一：列表，元组"><a href="#5-python容器一：列表，元组" class="headerlink" title="5.python容器一：列表，元组"></a>5.python容器一：列表，元组</h1><h2 id="1-列表"><a href="#1-列表" class="headerlink" title="1.列表"></a>1.列表</h2><p>列表（list）可以存储多个不同类型的数据 </p>
<p>列表可以通过下标(从 0 开始)来访问 </p>
<p>列表的长度不是固定的</p>
<h3 id="列表的声明方式"><a href="#列表的声明方式" class="headerlink" title="列表的声明方式"></a>列表的声明方式</h3><p><code>student=[&#39;jack&#39;,&#39;bob&#39;,123]</code></p>
<p>通过下标访问</p>
<p><code>print(classmates(0))</code></p>
<h3 id="列表的方法"><a href="#列表的方法" class="headerlink" title="列表的方法"></a>列表的方法</h3><p>使用 len()函数可以获得 list 的个数</p>
<p><code>print(len(student))</code></p>
<p>返回值为list元素的个数</p>
<p>使用 pop()函数可以删除 list 末尾的元素</p>
<p><code>student.pop()</code></p>
<p>也可按下标删除</p>
<p><code>student.pop(2)</code></p>
<p>append()添加元素</p>
<p><code>student.append(&quot;张飞&quot;)</code></p>
<h2 id="2-元组"><a href="#2-元组" class="headerlink" title="2.元组"></a>2.元组</h2><p>元祖也是一个容器，可以用来存储数据，不过区别在于： </p>
<p>元祖的长度一旦声明不可以更改、元祖的存储值用的小括号</p>
<p><code>classmates=(&quot;张飞&quot;,&quot;赵云&quot;,&quot;马超&quot;)</code></p>
<p>通过下标访问</p>
<p><code>print(classmates(0))</code></p>
<h1 id="6-python的条件控制"><a href="#6-python的条件控制" class="headerlink" title="6.python的条件控制"></a>6.python的条件控制</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	statement_block_3</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li><p>1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。</p>
</li>
<li><p>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</p>
</li>
<li><p>3、在Python中没有switch – case语句。</p>
</li>
</ul>
<h2 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h2><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p>
<h1 id="7-python的循环语句"><a href="#7-python的循环语句" class="headerlink" title="7.python的循环语句"></a>7.python的循环语句</h1><p>Python 中的循环语句有 for 和 while。</p>
<h2 id="while循环格式"><a href="#while循环格式" class="headerlink" title="while循环格式"></a>while循环格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">循环的初始化变量 </span><br><span class="line">While 循环的判断条件：</span><br><span class="line">	循环体语句</span><br><span class="line">    控制循环语句</span><br></pre></td></tr></table></figure>

<h2 id="for循环格式"><a href="#for循环格式" class="headerlink" title="for循环格式"></a>for循环格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in range(1,51):</span><br><span class="line">	print(x)</span><br></pre></td></tr></table></figure>

<h1 id="8-python的容器二：字典"><a href="#8-python的容器二：字典" class="headerlink" title="8.python的容器二：字典"></a>8.python的容器二：字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。 </p>
<p>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整 </p>
<p>个字典包括在花括号({})中 ,格式如下所示：</p>
<p><code>d = &#123;key1 : value1, key2 : value2 &#125;</code></p>
<p>键必须是唯一的，但值则不必。 </p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 </p>
<p>一个简单的字典实例 </p>
<p><code>dict = &#123;&#39;Alice&#39;: &#39;2341&#39;, &#39;Beth&#39;: &#39;9102&#39;, &#39;Cecil&#39;: &#39;3258&#39;&#125;</code></p>
<h2 id="1-访问字典里的值"><a href="#1-访问字典里的值" class="headerlink" title="1.访问字典里的值"></a>1.访问字典里的值</h2><p>通过访问key来找value</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;W3CSchool&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Age&#x27;]):&quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="2-修改字典"><a href="#2-修改字典" class="headerlink" title="2.修改字典"></a>2.修改字典</h2><p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实 </p>
<p>例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;W3CSchool&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125; </span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>] = <span class="number">8</span>; <span class="comment"># 更新 Age </span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>] = <span class="string">&quot;python 教程&quot;</span> <span class="comment"># 添加信息 </span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;School&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="3-删除字典元素"><a href="#3-删除字典元素" class="headerlink" title="3.删除字典元素"></a>3.删除字典元素</h2><p>能删单一的元素也能清空字典，清空只需一项操作。 </p>
<p>显示删除一个字典用 del 命令，如下实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;W3CSchool&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125; </span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27; </span></span><br><span class="line"><span class="built_in">dict</span>.clear() <span class="comment"># 删除字典 </span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span> <span class="comment"># 删除字典 </span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;School&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="4-字典键-key-的特性"><a href="#4-字典键-key-的特性" class="headerlink" title="4.字典键(key)的特性"></a>4.字典键(key)的特性</h2><p>1.不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记 </p>
<p>住</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;小菜鸟&#x27;</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>]) </span><br></pre></td></tr></table></figure>

<p>2.键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下 </p>
<p>实例： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="5-字典内置函数-amp-方法"><a href="#5-字典内置函数-amp-方法" class="headerlink" title="5.字典内置函数&amp;方法"></a>5.字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数及描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>len(dict) 计算字典元素个数，即键的总数。</td>
<td><code>&gt;&gt;&gt; dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(dict) 3</code></td>
</tr>
<tr>
<td>2</td>
<td>str(dict) 输出字典，可以打印的字符串表示。</td>
<td><code>&gt;&gt;&gt; dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(dict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td>
</tr>
<tr>
<td>3</td>
<td>type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td>
<td><code>&gt;&gt;&gt; dict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(dict) &lt;class &#39;dict&#39;&gt;</code></td>
</tr>
</tbody></table>
<h1 id="9-python迭代器"><a href="#9-python迭代器" class="headerlink" title="9.python迭代器"></a>9.python迭代器</h1><h2 id="1-迭代器："><a href="#1-迭代器：" class="headerlink" title="1. 迭代器："></a>1. 迭代器：</h2><p>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。。 </p>
<p>迭代器是一个可以记住遍历的位置的对象。 </p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代 </p>
<p>器只能往前不会后退。 </p>
<p>迭代器有两个基本的方法：iter() 和 next()。 </p>
<p>字符串，列表或元组对象都可用于创建迭代器： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个 list </span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line"><span class="comment">#创建迭代器对象 </span></span><br><span class="line">it=<span class="built_in">iter</span>(<span class="built_in">list</span>) </span><br><span class="line"><span class="comment">#开始迭代第 1 个元素 1 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it)) </span><br><span class="line"><span class="comment">#开始迭代第 2 个</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>

<p>迭代器对象可以使用常规 for 语句进行遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>) <span class="comment"># 创建迭代器对象 </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">	<span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也可以使用 next() 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>) <span class="comment"># 创建迭代器对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it)) </span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<h1 id="10-Python的单线程与多线程"><a href="#10-Python的单线程与多线程" class="headerlink" title="10.Python的单线程与多线程"></a>10.Python的单线程与多线程</h1><h2 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1)什么是进程?"></a>1)什么是进程?</h2><p>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基 </p>
<p>本单位，是操作系统结构的基础。 </p>
<h2 id="2-什么是线程"><a href="#2-什么是线程" class="headerlink" title="2) 什么是线程?"></a>2) 什么是线程?</h2><p>有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。 线 </p>
<p>程是进程中的一个实体，是被系统独立调度和分派的基本单位，一个进程可以包含多个线程， </p>
<p>但是线程不能包含多个进程。线程自己不拥有系统资源 ，在单个程序中同时运行多个线程 </p>
<p>完成不同的工作，称为多线程。 </p>
<h2 id="3-线程与进程的区别？"><a href="#3-线程与进程的区别？" class="headerlink" title="3) 线程与进程的区别？"></a>3) 线程与进程的区别？</h2><p>线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享 </p>
<p>数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。</p>
<p>提示： </p>
<p>LoadRunner 和 Jmeter 等性能测试工具也利用了多线程和多进程来构造多个并发用户来执 </p>
<p>行性能测试。 </p>
<p>线程与进程图文解释 </p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a> </p>
<h2 id="4-单线程"><a href="#4-单线程" class="headerlink" title="4)单线程"></a>4)单线程</h2><p>单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面 </p>
<p>的才会执行。 </p>
<p>案例：一个学生先用 2 秒说话，接着用 3 秒写字，最后结束。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime,sleep </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span>():</span> </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Start talk %r&quot;</span> %ctime()) </span><br><span class="line">    sleep(<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>():</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start Write! %r&quot;</span> %ctime()) </span><br><span class="line">    sleep(<span class="number">3</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">    talk() </span><br><span class="line">    write() </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All end %r&quot;</span> %ctime()) </span><br></pre></td></tr></table></figure>

<p>if <strong>name</strong>==”<strong>main</strong>“: 表示如果当前模块是被直接运行的，则该语句之后代码块被运 </p>
<p>行，如果模块是被导入的，则代码块不被运行。</p>
<h2 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5) 多线程"></a>5) 多线程</h2><p>多线程（MultiThreading）是指从软件或者硬件上实现多个线程并发执行的技术。 </p>
<p>案例：让学生同时进行说和写操作 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from time import ctime,sleep </span><br><span class="line"></span><br><span class="line">import threading </span><br><span class="line"></span><br><span class="line">def talk(content,loop): </span><br><span class="line">	for i in range(loop): </span><br><span class="line">		print(&quot;Start Talk %s %s&quot; %(content,ctime())) </span><br><span class="line">		sleep(3) </span><br><span class="line"></span><br><span class="line">def write(content,loop): </span><br><span class="line">	for i in range(loop): </span><br><span class="line">		print(&quot;Start Write %s %s&quot; %(content,ctime())) </span><br><span class="line">		sleep(5) </span><br><span class="line"></span><br><span class="line">threads=[] </span><br><span class="line"></span><br><span class="line">t1=threading.Thread(target=talk,args=(&#x27;Speak: Hello&#x27;,2)) </span><br><span class="line"></span><br><span class="line">threads.append(t1) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t2=threading.Thread(target=write,args=(&#x27;Write: Life is Short You need Python!&#x27;,2)) </span><br><span class="line"></span><br><span class="line">threads.append(t2) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;: </span><br><span class="line"></span><br><span class="line">    for t in threads: </span><br><span class="line">        t.start() </span><br><span class="line"></span><br><span class="line">	for t in threads: </span><br><span class="line">		t.join() </span><br><span class="line">	print(&quot;All the End %r&quot; %ctime()) </span><br></pre></td></tr></table></figure>

<h2 id="6-多进程"><a href="#6-多进程" class="headerlink" title="6) 多进程"></a>6) 多进程</h2><p>与多线程相比，多进程就是 import multiprocessing </p>
<p>然后替换相应的方法 multiprocessing.Process（） </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from time import sleep,ctime</span><br><span class="line">import multiprocessing </span><br><span class="line"></span><br><span class="line">def talk(content,loop): </span><br><span class="line"></span><br><span class="line">	for i in range(loop): </span><br><span class="line">		print(&quot;Talk: %s %s&quot; %(content,ctime())) </span><br><span class="line">		sleep(2) </span><br><span class="line"></span><br><span class="line">def write(content,loop): </span><br><span class="line">	for i in range(loop): </span><br><span class="line">		print(&quot;Write: %s %s&quot;%(content,ctime())) </span><br><span class="line">		sleep(3) </span><br><span class="line"></span><br><span class="line">process=[] </span><br><span class="line"></span><br><span class="line">p1=multiprocessing.Process(target=talk,args=(&#x27;hello&#x27;,2)) </span><br><span class="line"></span><br><span class="line">process.append(p1) </span><br><span class="line"></span><br><span class="line">p2=multiprocessing.Process(target=write,args=(&#x27;Python&#x27;,2)) </span><br><span class="line"></span><br><span class="line">process.append(p2) </span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;: </span><br><span class="line"></span><br><span class="line">    for p in process: </span><br><span class="line">        p.start() </span><br><span class="line">    for p in process: </span><br><span class="line">        p.join() </span><br><span class="line"></span><br><span class="line">    print(&quot;All process is Run %s&quot; %ctime())</span><br></pre></td></tr></table></figure>

<h1 id="11-Python-的爬虫案例"><a href="#11-Python-的爬虫案例" class="headerlink" title="11.Python 的爬虫案例"></a>11.Python 的爬虫案例</h1><p>从网页页面上批量下载 jpg 格式图片，并按照数字递增命名保存到指定的文件夹。 </p>
<p>Web 地址：<a target="_blank" rel="noopener" href="http://p.weather.com.cn/2017/06/2720826.shtml#p=1">http://p.weather.com.cn/2017/06/2720826.shtml#p=1</a> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib </span><br><span class="line"><span class="keyword">import</span> urllib.request </span><br><span class="line"><span class="keyword">import</span> re <span class="comment">#正则表达式 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解析页面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_page</span>(<span class="params">url</span>):</span> </span><br><span class="line"></span><br><span class="line">request=urllib.request.Request(url) <span class="comment">#发送网络请求 </span></span><br><span class="line"></span><br><span class="line">response=urllib.request.urlopen(request)<span class="comment">#根据 url 打开页面 </span></span><br><span class="line"></span><br><span class="line">data=response.read() <span class="comment">#获取页面响应数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data </span><br><span class="line"></span><br><span class="line"><span class="comment">#下载图片 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_image</span>(<span class="params">html</span>):</span> </span><br><span class="line"></span><br><span class="line">regx=<span class="string">r&#x27;http://[\S]jpg&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#定义正则表达式，匹配页面图片元素 </span></span><br><span class="line"></span><br><span class="line">pattern=re.<span class="built_in">compile</span>(regx) </span><br><span class="line"></span><br><span class="line"><span class="comment">#编译表达式构造匹配模式 </span></span><br><span class="line"></span><br><span class="line">get_image=re.findall(pattern,<span class="built_in">repr</span>(html)) <span class="comment">#进行正则匹配并返回结果 </span></span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历获取的图片 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> get_image: </span><br><span class="line"></span><br><span class="line">image=load_page(img) </span><br><span class="line"></span><br><span class="line"><span class="comment">#将图片存入到指定文件夹 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;E:\\Photo\\%s.jpg&#x27;</span> %num,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fb: </span><br><span class="line"></span><br><span class="line">fb.write(image) </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在下载第 %s 张图片&quot;</span> %num) </span><br><span class="line"></span><br><span class="line">num = num + <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下载完成！&quot;</span>) </span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;http://p.weather.com.cn/2017/06/2720826.shtml#p=1&#x27;</span> </span><br><span class="line"></span><br><span class="line">html=load_page(url) </span><br><span class="line"></span><br><span class="line">get_image(html) </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/30/python%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/" data-id="cksya86lp0000kktyblv7fwv8" data-title="python学习相关" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-selenium自动化测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/30/selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-08-30T06:42:47.000Z" itemprop="datePublished">2021-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/30/selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">selenium自动化测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/30/selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" data-id="cksy9ywst0000qktyde5gaza7" data-title="selenium自动化测试" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/10/python%E5%8F%91%E9%80%81%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E7%9A%84%E6%A8%A1%E6%9D%BF/">python发送测试报告的模板</a>
          </li>
        
          <li>
            <a href="/2021/09/08/appium%E5%AD%A6%E4%B9%A0/">appium学习</a>
          </li>
        
          <li>
            <a href="/2021/09/07/python%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">python单元测试</a>
          </li>
        
          <li>
            <a href="/2021/09/07/web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">web自动化测试</a>
          </li>
        
          <li>
            <a href="/2021/09/03/linux%E5%AD%A6%E4%B9%A0/">linux学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>